
usr/bin/init:     file format elf64-x86-64


Disassembly of section .text:

0000000000401000 <_putchar>:
  401000:	55                   	push   %rbp
  401001:	48 89 e5             	mov    %rsp,%rbp
  401004:	48 83 ec 10          	sub    $0x10,%rsp
  401008:	89 f8                	mov    %edi,%eax
  40100a:	88 45 fc             	mov    %al,-0x4(%rbp)
  40100d:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  401011:	ba 01 00 00 00       	mov    $0x1,%edx
  401016:	48 89 c6             	mov    %rax,%rsi
  401019:	bf 01 00 00 00       	mov    $0x1,%edi
  40101e:	e8 44 1a 00 00       	call   402a67 <write>
  401023:	90                   	nop
  401024:	c9                   	leave
  401025:	c3                   	ret

0000000000401026 <puts>:
  401026:	55                   	push   %rbp
  401027:	48 89 e5             	mov    %rsp,%rbp
  40102a:	48 83 ec 10          	sub    $0x10,%rsp
  40102e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  401032:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401036:	48 89 c7             	mov    %rax,%rdi
  401039:	e8 54 1d 00 00       	call   402d92 <strlen>
  40103e:	48 89 c2             	mov    %rax,%rdx
  401041:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401045:	48 89 c6             	mov    %rax,%rsi
  401048:	bf 00 00 00 00       	mov    $0x0,%edi
  40104d:	e8 15 1a 00 00       	call   402a67 <write>
  401052:	90                   	nop
  401053:	c9                   	leave
  401054:	c3                   	ret

0000000000401055 <main>:
  401055:	55                   	push   %rbp
  401056:	48 89 e5             	mov    %rsp,%rbp
  401059:	48 83 ec 10          	sub    $0x10,%rsp
  40105d:	ba 00 00 00 00       	mov    $0x0,%edx
  401062:	be 00 00 00 00       	mov    $0x0,%esi
  401067:	bf 00 30 40 00       	mov    $0x403000,%edi
  40106c:	e8 ca 19 00 00       	call   402a3b <open>
  401071:	89 45 fc             	mov    %eax,-0x4(%rbp)
  401074:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401077:	89 c7                	mov    %eax,%edi
  401079:	e8 3d 1a 00 00       	call   402abb <exit>
  40107e:	bf 10 30 40 00       	mov    $0x403010,%edi
  401083:	e8 9e ff ff ff       	call   401026 <puts>
  401088:	ba 05 00 00 00       	mov    $0x5,%edx
  40108d:	be 6f 30 40 00       	mov    $0x40306f,%esi
  401092:	bf 20 40 40 00       	mov    $0x404020,%edi
  401097:	b8 00 00 00 00       	mov    $0x0,%eax
  40109c:	e8 87 16 00 00       	call   402728 <sprintf_>
  4010a1:	b8 00 00 00 00       	mov    $0x0,%eax
  4010a6:	c9                   	leave
  4010a7:	c3                   	ret
  4010a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4010af:	00 

00000000004010b0 <_start>:
%define HEAP_REQUIRED_SIZE_OFF 17
%define HEAP_FREE_OFF          25

section .text
_start:
    mov rbp, rsp
  4010b0:	48 89 e5             	mov    %rsp,%rbp
    call init_libc
  4010b3:	e8 11 00 00 00       	call   4010c9 <init_libc>
    call main
  4010b8:	e8 98 ff ff ff       	call   401055 <main>
    mov rdi, rax
  4010bd:	48 89 c7             	mov    %rax,%rdi
    mov rax, 4
  4010c0:	b8 04 00 00 00       	mov    $0x4,%eax
    int 0x80
  4010c5:	cd 80                	int    $0x80
    jmp $ ; in case exit failed, loop forever
  4010c7:	eb fe                	jmp    4010c7 <_start+0x17>

00000000004010c9 <init_libc>:

init_libc:
    ;; Initiate the heap
    ; Get the location of the start of the heap
    mov rax, 11 ; sbrk(
  4010c9:	b8 0b 00 00 00       	mov    $0xb,%eax
    mov rdi, 0  ;   0
  4010ce:	bf 00 00 00 00       	mov    $0x0,%edi
    int 0x80    ; );
  4010d3:	cd 80                	int    $0x80
    mov [start_heap], rax
  4010d5:	48 89 04 25 00 40 40 	mov    %rax,0x404000
  4010dc:	00 
    ; Move the program break forward by a page
    mov rax, 11   ; sbrk(
  4010dd:	b8 0b 00 00 00       	mov    $0xb,%eax
    mov rdi, 4096 ;   4096
  4010e2:	bf 00 10 00 00       	mov    $0x1000,%edi
    int 0x80      ; );
  4010e7:	cd 80                	int    $0x80
    ; Fill the heap so far with a single pool
    mov byte  [start_heap + HEAP_VERIFY_OFF       ], 69
  4010e9:	c6 04 25 00 40 40 00 	movb   $0x45,0x404000
  4010f0:	45 
    mov qword [start_heap + HEAP_NEXT_OFF         ], 0
  4010f1:	48 c7 04 25 01 40 40 	movq   $0x0,0x404001
  4010f8:	00 00 00 00 00 
    mov qword [start_heap + HEAP_POOL_SIZE_OFF    ], 4095
  4010fd:	48 c7 04 25 09 40 40 	movq   $0xfff,0x404009
  401104:	00 ff 0f 00 00 
    mov qword [start_heap + HEAP_REQUIRED_SIZE_OFF], 4095
  401109:	48 c7 04 25 11 40 40 	movq   $0xfff,0x404011
  401110:	00 ff 0f 00 00 
    mov byte  [start_heap + HEAP_FREE_OFF         ], 1
  401115:	c6 04 25 19 40 40 00 	movb   $0x1,0x404019
  40111c:	01 
    ret
  40111d:	c3                   	ret

000000000040111e <_putchar>:
/**
 * Output a character to a custom device like UART, used by the printf() function
 * This function is declared here only. You have to write your custom implementation somewhere
 * \param character Character to output
 */
static void _putchar(char character) {
  40111e:	55                   	push   %rbp
  40111f:	48 89 e5             	mov    %rsp,%rbp
  401122:	48 83 ec 10          	sub    $0x10,%rsp
  401126:	89 f8                	mov    %edi,%eax
  401128:	88 45 fc             	mov    %al,-0x4(%rbp)
    write(1, &character, 1);
  40112b:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  40112f:	ba 01 00 00 00       	mov    $0x1,%edx
  401134:	48 89 c6             	mov    %rax,%rsi
  401137:	bf 01 00 00 00       	mov    $0x1,%edi
  40113c:	e8 26 19 00 00       	call   402a67 <write>
}
  401141:	90                   	nop
  401142:	c9                   	leave
  401143:	c3                   	ret

0000000000401144 <_out_buffer>:
} out_fct_wrap_type;


// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
{
  401144:	55                   	push   %rbp
  401145:	48 89 e5             	mov    %rsp,%rbp
  401148:	89 f8                	mov    %edi,%eax
  40114a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  40114e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  401152:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  401156:	88 45 fc             	mov    %al,-0x4(%rbp)
  if (idx < maxlen) {
  401159:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40115d:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  401161:	73 11                	jae    401174 <_out_buffer+0x30>
    ((char*)buffer)[idx] = character;
  401163:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  401167:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40116b:	48 01 c2             	add    %rax,%rdx
  40116e:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  401172:	88 02                	mov    %al,(%rdx)
  }
}
  401174:	90                   	nop
  401175:	5d                   	pop    %rbp
  401176:	c3                   	ret

0000000000401177 <_out_null>:


// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
  401177:	55                   	push   %rbp
  401178:	48 89 e5             	mov    %rsp,%rbp
  40117b:	89 f8                	mov    %edi,%eax
  40117d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  401181:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  401185:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  401189:	88 45 fc             	mov    %al,-0x4(%rbp)
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
  40118c:	90                   	nop
  40118d:	5d                   	pop    %rbp
  40118e:	c3                   	ret

000000000040118f <_out_char>:


// internal _putchar wrapper
static inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)
{
  40118f:	55                   	push   %rbp
  401190:	48 89 e5             	mov    %rsp,%rbp
  401193:	48 83 ec 20          	sub    $0x20,%rsp
  401197:	89 f8                	mov    %edi,%eax
  401199:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  40119d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  4011a1:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  4011a5:	88 45 fc             	mov    %al,-0x4(%rbp)
  (void)buffer; (void)idx; (void)maxlen;
  if (character) {
  4011a8:	80 7d fc 00          	cmpb   $0x0,-0x4(%rbp)
  4011ac:	74 0b                	je     4011b9 <_out_char+0x2a>
    _putchar(character);
  4011ae:	0f be 45 fc          	movsbl -0x4(%rbp),%eax
  4011b2:	89 c7                	mov    %eax,%edi
  4011b4:	e8 65 ff ff ff       	call   40111e <_putchar>
  }
}
  4011b9:	90                   	nop
  4011ba:	c9                   	leave
  4011bb:	c3                   	ret

00000000004011bc <_out_fct>:


// internal output function wrapper
static inline void _out_fct(char character, void* buffer, size_t idx, size_t maxlen)
{
  4011bc:	55                   	push   %rbp
  4011bd:	48 89 e5             	mov    %rsp,%rbp
  4011c0:	48 83 ec 20          	sub    $0x20,%rsp
  4011c4:	89 f8                	mov    %edi,%eax
  4011c6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  4011ca:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  4011ce:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  4011d2:	88 45 fc             	mov    %al,-0x4(%rbp)
  (void)idx; (void)maxlen;
  if (character) {
  4011d5:	80 7d fc 00          	cmpb   $0x0,-0x4(%rbp)
  4011d9:	74 1a                	je     4011f5 <_out_fct+0x39>
    // buffer is the output fct pointer
    ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);
  4011db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4011df:	48 8b 08             	mov    (%rax),%rcx
  4011e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4011e6:	48 8b 50 08          	mov    0x8(%rax),%rdx
  4011ea:	0f be 45 fc          	movsbl -0x4(%rbp),%eax
  4011ee:	48 89 d6             	mov    %rdx,%rsi
  4011f1:	89 c7                	mov    %eax,%edi
  4011f3:	ff d1                	call   *%rcx
  }
}
  4011f5:	90                   	nop
  4011f6:	c9                   	leave
  4011f7:	c3                   	ret

00000000004011f8 <_strnlen_s>:


// internal secure strlen
// \return The length of the string (excluding the terminating 0) limited by 'maxsize'
static inline unsigned int _strnlen_s(const char* str, size_t maxsize)
{
  4011f8:	55                   	push   %rbp
  4011f9:	48 89 e5             	mov    %rsp,%rbp
  4011fc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401200:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  const char* s;
  for (s = str; *s && maxsize--; ++s);
  401204:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401208:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  40120c:	eb 05                	jmp    401213 <_strnlen_s+0x1b>
  40120e:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  401213:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401217:	0f b6 00             	movzbl (%rax),%eax
  40121a:	84 c0                	test   %al,%al
  40121c:	74 11                	je     40122f <_strnlen_s+0x37>
  40121e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401222:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  401226:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  40122a:	48 85 c0             	test   %rax,%rax
  40122d:	75 df                	jne    40120e <_strnlen_s+0x16>
  return (unsigned int)(s - str);
  40122f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401233:	48 2b 45 e8          	sub    -0x18(%rbp),%rax
}
  401237:	5d                   	pop    %rbp
  401238:	c3                   	ret

0000000000401239 <_is_digit>:


// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch)
{
  401239:	55                   	push   %rbp
  40123a:	48 89 e5             	mov    %rsp,%rbp
  40123d:	89 f8                	mov    %edi,%eax
  40123f:	88 45 fc             	mov    %al,-0x4(%rbp)
  return (ch >= '0') && (ch <= '9');
  401242:	80 7d fc 2f          	cmpb   $0x2f,-0x4(%rbp)
  401246:	7e 0d                	jle    401255 <_is_digit+0x1c>
  401248:	80 7d fc 39          	cmpb   $0x39,-0x4(%rbp)
  40124c:	7f 07                	jg     401255 <_is_digit+0x1c>
  40124e:	b8 01 00 00 00       	mov    $0x1,%eax
  401253:	eb 05                	jmp    40125a <_is_digit+0x21>
  401255:	b8 00 00 00 00       	mov    $0x0,%eax
  40125a:	83 e0 01             	and    $0x1,%eax
}
  40125d:	5d                   	pop    %rbp
  40125e:	c3                   	ret

000000000040125f <_atoi>:


// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char** str)
{
  40125f:	55                   	push   %rbp
  401260:	48 89 e5             	mov    %rsp,%rbp
  401263:	48 83 ec 18          	sub    $0x18,%rsp
  401267:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  unsigned int i = 0U;
  40126b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  while (_is_digit(**str)) {
  401272:	eb 2e                	jmp    4012a2 <_atoi+0x43>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  401274:	8b 55 fc             	mov    -0x4(%rbp),%edx
  401277:	89 d0                	mov    %edx,%eax
  401279:	c1 e0 02             	shl    $0x2,%eax
  40127c:	01 d0                	add    %edx,%eax
  40127e:	01 c0                	add    %eax,%eax
  401280:	89 c6                	mov    %eax,%esi
  401282:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401286:	48 8b 00             	mov    (%rax),%rax
  401289:	48 8d 48 01          	lea    0x1(%rax),%rcx
  40128d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401291:	48 89 0a             	mov    %rcx,(%rdx)
  401294:	0f b6 00             	movzbl (%rax),%eax
  401297:	0f be c0             	movsbl %al,%eax
  40129a:	01 f0                	add    %esi,%eax
  40129c:	83 e8 30             	sub    $0x30,%eax
  40129f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  while (_is_digit(**str)) {
  4012a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4012a6:	48 8b 00             	mov    (%rax),%rax
  4012a9:	0f b6 00             	movzbl (%rax),%eax
  4012ac:	0f be c0             	movsbl %al,%eax
  4012af:	89 c7                	mov    %eax,%edi
  4012b1:	e8 83 ff ff ff       	call   401239 <_is_digit>
  4012b6:	84 c0                	test   %al,%al
  4012b8:	75 ba                	jne    401274 <_atoi+0x15>
  }
  return i;
  4012ba:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  4012bd:	c9                   	leave
  4012be:	c3                   	ret

00000000004012bf <_out_rev>:


// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)
{
  4012bf:	55                   	push   %rbp
  4012c0:	48 89 e5             	mov    %rsp,%rbp
  4012c3:	48 83 ec 40          	sub    $0x40,%rsp
  4012c7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4012cb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4012cf:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  4012d3:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  4012d7:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  4012db:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  const size_t start_idx = idx;
  4012df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4012e3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
  4012e7:	8b 45 18             	mov    0x18(%rbp),%eax
  4012ea:	83 e0 02             	and    $0x2,%eax
  4012ed:	85 c0                	test   %eax,%eax
  4012ef:	0f 85 81 00 00 00    	jne    401376 <_out_rev+0xb7>
  4012f5:	8b 45 18             	mov    0x18(%rbp),%eax
  4012f8:	83 e0 01             	and    $0x1,%eax
  4012fb:	85 c0                	test   %eax,%eax
  4012fd:	75 77                	jne    401376 <_out_rev+0xb7>
    for (size_t i = len; i < width; i++) {
  4012ff:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  401303:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  401307:	eb 2b                	jmp    401334 <_out_rev+0x75>
      out(' ', buffer, idx++, maxlen);
  401309:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40130d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  401311:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  401315:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  401319:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  40131d:	4c 8b 45 e8          	mov    -0x18(%rbp),%r8
  401321:	48 89 d1             	mov    %rdx,%rcx
  401324:	48 89 c2             	mov    %rax,%rdx
  401327:	bf 20 00 00 00       	mov    $0x20,%edi
  40132c:	41 ff d0             	call   *%r8
    for (size_t i = len; i < width; i++) {
  40132f:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  401334:	8b 45 10             	mov    0x10(%rbp),%eax
  401337:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  40133b:	72 cc                	jb     401309 <_out_rev+0x4a>
    }
  }

  // reverse string
  while (len) {
  40133d:	eb 37                	jmp    401376 <_out_rev+0xb7>
    out(buf[--len], buffer, idx++, maxlen);
  40133f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401343:	48 8d 50 01          	lea    0x1(%rax),%rdx
  401347:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  40134b:	48 83 6d c0 01       	subq   $0x1,-0x40(%rbp)
  401350:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  401354:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  401358:	48 01 ca             	add    %rcx,%rdx
  40135b:	0f b6 12             	movzbl (%rdx),%edx
  40135e:	0f be fa             	movsbl %dl,%edi
  401361:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  401365:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  401369:	4c 8b 45 e8          	mov    -0x18(%rbp),%r8
  40136d:	48 89 d1             	mov    %rdx,%rcx
  401370:	48 89 c2             	mov    %rax,%rdx
  401373:	41 ff d0             	call   *%r8
  while (len) {
  401376:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  40137b:	75 c2                	jne    40133f <_out_rev+0x80>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
  40137d:	8b 45 18             	mov    0x18(%rbp),%eax
  401380:	83 e0 02             	and    $0x2,%eax
  401383:	85 c0                	test   %eax,%eax
  401385:	74 3b                	je     4013c2 <_out_rev+0x103>
    while (idx - start_idx < width) {
  401387:	eb 26                	jmp    4013af <_out_rev+0xf0>
      out(' ', buffer, idx++, maxlen);
  401389:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40138d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  401391:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  401395:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  401399:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  40139d:	4c 8b 45 e8          	mov    -0x18(%rbp),%r8
  4013a1:	48 89 d1             	mov    %rdx,%rcx
  4013a4:	48 89 c2             	mov    %rax,%rdx
  4013a7:	bf 20 00 00 00       	mov    $0x20,%edi
  4013ac:	41 ff d0             	call   *%r8
    while (idx - start_idx < width) {
  4013af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4013b3:	48 2b 45 f0          	sub    -0x10(%rbp),%rax
  4013b7:	48 89 c2             	mov    %rax,%rdx
  4013ba:	8b 45 10             	mov    0x10(%rbp),%eax
  4013bd:	48 39 c2             	cmp    %rax,%rdx
  4013c0:	72 c7                	jb     401389 <_out_rev+0xca>
    }
  }

  return idx;
  4013c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
}
  4013c6:	c9                   	leave
  4013c7:	c3                   	ret

00000000004013c8 <_ntoa_format>:


// internal itoa format
static size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)
{
  4013c8:	55                   	push   %rbp
  4013c9:	48 89 e5             	mov    %rsp,%rbp
  4013cc:	48 83 ec 40          	sub    $0x40,%rsp
  4013d0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  4013d4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  4013d8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  4013dc:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  4013e0:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  4013e4:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
  4013e8:	8b 45 10             	mov    0x10(%rbp),%eax
  4013eb:	88 45 cc             	mov    %al,-0x34(%rbp)
  // pad leading zeros
  if (!(flags & FLAGS_LEFT)) {
  4013ee:	8b 45 30             	mov    0x30(%rbp),%eax
  4013f1:	83 e0 02             	and    $0x2,%eax
  4013f4:	85 c0                	test   %eax,%eax
  4013f6:	75 7e                	jne    401476 <_ntoa_format+0xae>
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  4013f8:	83 7d 28 00          	cmpl   $0x0,0x28(%rbp)
  4013fc:	74 36                	je     401434 <_ntoa_format+0x6c>
  4013fe:	8b 45 30             	mov    0x30(%rbp),%eax
  401401:	83 e0 01             	and    $0x1,%eax
  401404:	85 c0                	test   %eax,%eax
  401406:	74 2c                	je     401434 <_ntoa_format+0x6c>
  401408:	80 7d cc 00          	cmpb   $0x0,-0x34(%rbp)
  40140c:	75 0a                	jne    401418 <_ntoa_format+0x50>
  40140e:	8b 45 30             	mov    0x30(%rbp),%eax
  401411:	83 e0 0c             	and    $0xc,%eax
  401414:	85 c0                	test   %eax,%eax
  401416:	74 1c                	je     401434 <_ntoa_format+0x6c>
      width--;
  401418:	83 6d 28 01          	subl   $0x1,0x28(%rbp)
    }
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  40141c:	eb 16                	jmp    401434 <_ntoa_format+0x6c>
      buf[len++] = '0';
  40141e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401422:	48 8d 50 01          	lea    0x1(%rax),%rdx
  401426:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  40142a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  40142e:	48 01 d0             	add    %rdx,%rax
  401431:	c6 00 30             	movb   $0x30,(%rax)
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  401434:	8b 45 20             	mov    0x20(%rbp),%eax
  401437:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  40143b:	73 1f                	jae    40145c <_ntoa_format+0x94>
  40143d:	48 83 7d d0 1f       	cmpq   $0x1f,-0x30(%rbp)
  401442:	76 da                	jbe    40141e <_ntoa_format+0x56>
    }
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  401444:	eb 16                	jmp    40145c <_ntoa_format+0x94>
      buf[len++] = '0';
  401446:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40144a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  40144e:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  401452:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  401456:	48 01 d0             	add    %rdx,%rax
  401459:	c6 00 30             	movb   $0x30,(%rax)
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  40145c:	8b 45 30             	mov    0x30(%rbp),%eax
  40145f:	83 e0 01             	and    $0x1,%eax
  401462:	85 c0                	test   %eax,%eax
  401464:	74 10                	je     401476 <_ntoa_format+0xae>
  401466:	8b 45 28             	mov    0x28(%rbp),%eax
  401469:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  40146d:	73 07                	jae    401476 <_ntoa_format+0xae>
  40146f:	48 83 7d d0 1f       	cmpq   $0x1f,-0x30(%rbp)
  401474:	76 d0                	jbe    401446 <_ntoa_format+0x7e>
    }
  }

  // handle hash
  if (flags & FLAGS_HASH) {
  401476:	8b 45 30             	mov    0x30(%rbp),%eax
  401479:	83 e0 10             	and    $0x10,%eax
  40147c:	85 c0                	test   %eax,%eax
  40147e:	0f 84 da 00 00 00    	je     40155e <_ntoa_format+0x196>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
  401484:	8b 45 30             	mov    0x30(%rbp),%eax
  401487:	25 00 04 00 00       	and    $0x400,%eax
  40148c:	85 c0                	test   %eax,%eax
  40148e:	75 30                	jne    4014c0 <_ntoa_format+0xf8>
  401490:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  401495:	74 29                	je     4014c0 <_ntoa_format+0xf8>
  401497:	8b 45 20             	mov    0x20(%rbp),%eax
  40149a:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  40149e:	74 09                	je     4014a9 <_ntoa_format+0xe1>
  4014a0:	8b 45 28             	mov    0x28(%rbp),%eax
  4014a3:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  4014a7:	75 17                	jne    4014c0 <_ntoa_format+0xf8>
      len--;
  4014a9:	48 83 6d d0 01       	subq   $0x1,-0x30(%rbp)
      if (len && (base == 16U)) {
  4014ae:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  4014b3:	74 0b                	je     4014c0 <_ntoa_format+0xf8>
  4014b5:	83 7d 18 10          	cmpl   $0x10,0x18(%rbp)
  4014b9:	75 05                	jne    4014c0 <_ntoa_format+0xf8>
        len--;
  4014bb:	48 83 6d d0 01       	subq   $0x1,-0x30(%rbp)
      }
    }
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  4014c0:	83 7d 18 10          	cmpl   $0x10,0x18(%rbp)
  4014c4:	75 29                	jne    4014ef <_ntoa_format+0x127>
  4014c6:	8b 45 30             	mov    0x30(%rbp),%eax
  4014c9:	83 e0 20             	and    $0x20,%eax
  4014cc:	85 c0                	test   %eax,%eax
  4014ce:	75 1f                	jne    4014ef <_ntoa_format+0x127>
  4014d0:	48 83 7d d0 1f       	cmpq   $0x1f,-0x30(%rbp)
  4014d5:	77 18                	ja     4014ef <_ntoa_format+0x127>
      buf[len++] = 'x';
  4014d7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4014db:	48 8d 50 01          	lea    0x1(%rax),%rdx
  4014df:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  4014e3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  4014e7:	48 01 d0             	add    %rdx,%rax
  4014ea:	c6 00 78             	movb   $0x78,(%rax)
  4014ed:	eb 52                	jmp    401541 <_ntoa_format+0x179>
    }
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  4014ef:	83 7d 18 10          	cmpl   $0x10,0x18(%rbp)
  4014f3:	75 29                	jne    40151e <_ntoa_format+0x156>
  4014f5:	8b 45 30             	mov    0x30(%rbp),%eax
  4014f8:	83 e0 20             	and    $0x20,%eax
  4014fb:	85 c0                	test   %eax,%eax
  4014fd:	74 1f                	je     40151e <_ntoa_format+0x156>
  4014ff:	48 83 7d d0 1f       	cmpq   $0x1f,-0x30(%rbp)
  401504:	77 18                	ja     40151e <_ntoa_format+0x156>
      buf[len++] = 'X';
  401506:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40150a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  40150e:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  401512:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  401516:	48 01 d0             	add    %rdx,%rax
  401519:	c6 00 58             	movb   $0x58,(%rax)
  40151c:	eb 23                	jmp    401541 <_ntoa_format+0x179>
    }
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  40151e:	83 7d 18 02          	cmpl   $0x2,0x18(%rbp)
  401522:	75 1d                	jne    401541 <_ntoa_format+0x179>
  401524:	48 83 7d d0 1f       	cmpq   $0x1f,-0x30(%rbp)
  401529:	77 16                	ja     401541 <_ntoa_format+0x179>
      buf[len++] = 'b';
  40152b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40152f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  401533:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  401537:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  40153b:	48 01 d0             	add    %rdx,%rax
  40153e:	c6 00 62             	movb   $0x62,(%rax)
    }
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
  401541:	48 83 7d d0 1f       	cmpq   $0x1f,-0x30(%rbp)
  401546:	77 16                	ja     40155e <_ntoa_format+0x196>
      buf[len++] = '0';
  401548:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40154c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  401550:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  401554:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  401558:	48 01 d0             	add    %rdx,%rax
  40155b:	c6 00 30             	movb   $0x30,(%rax)
    }
  }

  if (len < PRINTF_NTOA_BUFFER_SIZE) {
  40155e:	48 83 7d d0 1f       	cmpq   $0x1f,-0x30(%rbp)
  401563:	77 60                	ja     4015c5 <_ntoa_format+0x1fd>
    if (negative) {
  401565:	80 7d cc 00          	cmpb   $0x0,-0x34(%rbp)
  401569:	74 18                	je     401583 <_ntoa_format+0x1bb>
      buf[len++] = '-';
  40156b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40156f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  401573:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  401577:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  40157b:	48 01 d0             	add    %rdx,%rax
  40157e:	c6 00 2d             	movb   $0x2d,(%rax)
  401581:	eb 42                	jmp    4015c5 <_ntoa_format+0x1fd>
    }
    else if (flags & FLAGS_PLUS) {
  401583:	8b 45 30             	mov    0x30(%rbp),%eax
  401586:	83 e0 04             	and    $0x4,%eax
  401589:	85 c0                	test   %eax,%eax
  40158b:	74 18                	je     4015a5 <_ntoa_format+0x1dd>
      buf[len++] = '+';  // ignore the space if the '+' exists
  40158d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401591:	48 8d 50 01          	lea    0x1(%rax),%rdx
  401595:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  401599:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  40159d:	48 01 d0             	add    %rdx,%rax
  4015a0:	c6 00 2b             	movb   $0x2b,(%rax)
  4015a3:	eb 20                	jmp    4015c5 <_ntoa_format+0x1fd>
    }
    else if (flags & FLAGS_SPACE) {
  4015a5:	8b 45 30             	mov    0x30(%rbp),%eax
  4015a8:	83 e0 08             	and    $0x8,%eax
  4015ab:	85 c0                	test   %eax,%eax
  4015ad:	74 16                	je     4015c5 <_ntoa_format+0x1fd>
      buf[len++] = ' ';
  4015af:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4015b3:	48 8d 50 01          	lea    0x1(%rax),%rdx
  4015b7:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  4015bb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  4015bf:	48 01 d0             	add    %rdx,%rax
  4015c2:	c6 00 20             	movb   $0x20,(%rax)
    }
  }

  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  4015c5:	4c 8b 4d d0          	mov    -0x30(%rbp),%r9
  4015c9:	4c 8b 45 d8          	mov    -0x28(%rbp),%r8
  4015cd:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  4015d1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  4015d5:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  4015d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4015dd:	8b 7d 30             	mov    0x30(%rbp),%edi
  4015e0:	57                   	push   %rdi
  4015e1:	8b 7d 28             	mov    0x28(%rbp),%edi
  4015e4:	57                   	push   %rdi
  4015e5:	48 89 c7             	mov    %rax,%rdi
  4015e8:	e8 d2 fc ff ff       	call   4012bf <_out_rev>
  4015ed:	48 83 c4 10          	add    $0x10,%rsp
}
  4015f1:	c9                   	leave
  4015f2:	c3                   	ret

00000000004015f3 <_ntoa_long>:


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
  4015f3:	55                   	push   %rbp
  4015f4:	48 89 e5             	mov    %rsp,%rbp
  4015f7:	48 83 ec 60          	sub    $0x60,%rsp
  4015fb:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  4015ff:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  401603:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  401607:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  40160b:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  40160f:	44 89 c8             	mov    %r9d,%eax
  401612:	88 45 a4             	mov    %al,-0x5c(%rbp)
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
  401615:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  40161c:	00 

  // no hash for 0 values
  if (!value) {
  40161d:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  401622:	75 04                	jne    401628 <_ntoa_long+0x35>
    flags &= ~FLAGS_HASH;
  401624:	83 65 28 ef          	andl   $0xffffffef,0x28(%rbp)
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
  401628:	8b 45 28             	mov    0x28(%rbp),%eax
  40162b:	25 00 04 00 00       	and    $0x400,%eax
  401630:	85 c0                	test   %eax,%eax
  401632:	74 07                	je     40163b <_ntoa_long+0x48>
  401634:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  401639:	74 74                	je     4016af <_ntoa_long+0xbc>
    do {
      const char digit = (char)(value % base);
  40163b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  40163f:	ba 00 00 00 00       	mov    $0x0,%edx
  401644:	48 f7 75 10          	divq   0x10(%rbp)
  401648:	48 89 d0             	mov    %rdx,%rax
  40164b:	88 45 f7             	mov    %al,-0x9(%rbp)
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  40164e:	80 7d f7 09          	cmpb   $0x9,-0x9(%rbp)
  401652:	7f 0b                	jg     40165f <_ntoa_long+0x6c>
  401654:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  401658:	83 c0 30             	add    $0x30,%eax
  40165b:	89 c1                	mov    %eax,%ecx
  40165d:	eb 21                	jmp    401680 <_ntoa_long+0x8d>
  40165f:	8b 45 28             	mov    0x28(%rbp),%eax
  401662:	83 e0 20             	and    $0x20,%eax
  401665:	85 c0                	test   %eax,%eax
  401667:	74 07                	je     401670 <_ntoa_long+0x7d>
  401669:	ba 41 00 00 00       	mov    $0x41,%edx
  40166e:	eb 05                	jmp    401675 <_ntoa_long+0x82>
  401670:	ba 61 00 00 00       	mov    $0x61,%edx
  401675:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  401679:	01 d0                	add    %edx,%eax
  40167b:	83 e8 0a             	sub    $0xa,%eax
  40167e:	89 c1                	mov    %eax,%ecx
  401680:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401684:	48 8d 50 01          	lea    0x1(%rax),%rdx
  401688:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  40168c:	88 4c 05 d0          	mov    %cl,-0x30(%rbp,%rax,1)
      value /= base;
  401690:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  401694:	ba 00 00 00 00       	mov    $0x0,%edx
  401699:	48 f7 75 10          	divq   0x10(%rbp)
  40169d:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  4016a1:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  4016a6:	74 07                	je     4016af <_ntoa_long+0xbc>
  4016a8:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  4016ad:	76 8c                	jbe    40163b <_ntoa_long+0x48>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
  4016af:	48 8b 45 10          	mov    0x10(%rbp),%rax
  4016b3:	41 89 c3             	mov    %eax,%r11d
  4016b6:	0f b6 7d a4          	movzbl -0x5c(%rbp),%edi
  4016ba:	4c 8b 4d f8          	mov    -0x8(%rbp),%r9
  4016be:	4c 8d 55 d0          	lea    -0x30(%rbp),%r10
  4016c2:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  4016c6:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  4016ca:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  4016ce:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  4016d2:	48 83 ec 08          	sub    $0x8,%rsp
  4016d6:	44 8b 45 28          	mov    0x28(%rbp),%r8d
  4016da:	41 50                	push   %r8
  4016dc:	44 8b 45 20          	mov    0x20(%rbp),%r8d
  4016e0:	41 50                	push   %r8
  4016e2:	44 8b 45 18          	mov    0x18(%rbp),%r8d
  4016e6:	41 50                	push   %r8
  4016e8:	41 53                	push   %r11
  4016ea:	57                   	push   %rdi
  4016eb:	4d 89 d0             	mov    %r10,%r8
  4016ee:	48 89 c7             	mov    %rax,%rdi
  4016f1:	e8 d2 fc ff ff       	call   4013c8 <_ntoa_format>
  4016f6:	48 83 c4 30          	add    $0x30,%rsp
}
  4016fa:	c9                   	leave
  4016fb:	c3                   	ret

00000000004016fc <_ntoa_long_long>:


// internal itoa for 'long long' type
#if defined(PRINTF_SUPPORT_LONG_LONG)
static size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)
{
  4016fc:	55                   	push   %rbp
  4016fd:	48 89 e5             	mov    %rsp,%rbp
  401700:	48 83 ec 60          	sub    $0x60,%rsp
  401704:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  401708:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  40170c:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  401710:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  401714:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  401718:	44 89 c8             	mov    %r9d,%eax
  40171b:	88 45 a4             	mov    %al,-0x5c(%rbp)
  char buf[PRINTF_NTOA_BUFFER_SIZE];
  size_t len = 0U;
  40171e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  401725:	00 

  // no hash for 0 values
  if (!value) {
  401726:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  40172b:	75 04                	jne    401731 <_ntoa_long_long+0x35>
    flags &= ~FLAGS_HASH;
  40172d:	83 65 28 ef          	andl   $0xffffffef,0x28(%rbp)
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
  401731:	8b 45 28             	mov    0x28(%rbp),%eax
  401734:	25 00 04 00 00       	and    $0x400,%eax
  401739:	85 c0                	test   %eax,%eax
  40173b:	74 07                	je     401744 <_ntoa_long_long+0x48>
  40173d:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  401742:	74 74                	je     4017b8 <_ntoa_long_long+0xbc>
    do {
      const char digit = (char)(value % base);
  401744:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  401748:	ba 00 00 00 00       	mov    $0x0,%edx
  40174d:	48 f7 75 10          	divq   0x10(%rbp)
  401751:	48 89 d0             	mov    %rdx,%rax
  401754:	88 45 f7             	mov    %al,-0x9(%rbp)
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  401757:	80 7d f7 09          	cmpb   $0x9,-0x9(%rbp)
  40175b:	7f 0b                	jg     401768 <_ntoa_long_long+0x6c>
  40175d:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  401761:	83 c0 30             	add    $0x30,%eax
  401764:	89 c1                	mov    %eax,%ecx
  401766:	eb 21                	jmp    401789 <_ntoa_long_long+0x8d>
  401768:	8b 45 28             	mov    0x28(%rbp),%eax
  40176b:	83 e0 20             	and    $0x20,%eax
  40176e:	85 c0                	test   %eax,%eax
  401770:	74 07                	je     401779 <_ntoa_long_long+0x7d>
  401772:	ba 41 00 00 00       	mov    $0x41,%edx
  401777:	eb 05                	jmp    40177e <_ntoa_long_long+0x82>
  401779:	ba 61 00 00 00       	mov    $0x61,%edx
  40177e:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  401782:	01 d0                	add    %edx,%eax
  401784:	83 e8 0a             	sub    $0xa,%eax
  401787:	89 c1                	mov    %eax,%ecx
  401789:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40178d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  401791:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  401795:	88 4c 05 d0          	mov    %cl,-0x30(%rbp,%rax,1)
      value /= base;
  401799:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  40179d:	ba 00 00 00 00       	mov    $0x0,%edx
  4017a2:	48 f7 75 10          	divq   0x10(%rbp)
  4017a6:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  4017aa:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  4017af:	74 07                	je     4017b8 <_ntoa_long_long+0xbc>
  4017b1:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  4017b6:	76 8c                	jbe    401744 <_ntoa_long_long+0x48>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
  4017b8:	48 8b 45 10          	mov    0x10(%rbp),%rax
  4017bc:	41 89 c3             	mov    %eax,%r11d
  4017bf:	0f b6 7d a4          	movzbl -0x5c(%rbp),%edi
  4017c3:	4c 8b 4d f8          	mov    -0x8(%rbp),%r9
  4017c7:	4c 8d 55 d0          	lea    -0x30(%rbp),%r10
  4017cb:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  4017cf:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  4017d3:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  4017d7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  4017db:	48 83 ec 08          	sub    $0x8,%rsp
  4017df:	44 8b 45 28          	mov    0x28(%rbp),%r8d
  4017e3:	41 50                	push   %r8
  4017e5:	44 8b 45 20          	mov    0x20(%rbp),%r8d
  4017e9:	41 50                	push   %r8
  4017eb:	44 8b 45 18          	mov    0x18(%rbp),%r8d
  4017ef:	41 50                	push   %r8
  4017f1:	41 53                	push   %r11
  4017f3:	57                   	push   %rdi
  4017f4:	4d 89 d0             	mov    %r10,%r8
  4017f7:	48 89 c7             	mov    %rax,%rdi
  4017fa:	e8 c9 fb ff ff       	call   4013c8 <_ntoa_format>
  4017ff:	48 83 c4 30          	add    $0x30,%rsp
}
  401803:	c9                   	leave
  401804:	c3                   	ret

0000000000401805 <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
  401805:	55                   	push   %rbp
  401806:	48 89 e5             	mov    %rsp,%rbp
  401809:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  40180d:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  401811:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  401815:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  401819:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
  40181d:	4c 89 45 88          	mov    %r8,-0x78(%rbp)
  unsigned int flags, width, precision, n;
  size_t idx = 0U;
  401821:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  401828:	00 

  if (!buffer) {
  401829:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  40182e:	0f 85 e5 0d 00 00    	jne    402619 <_vsnprintf+0xe14>
    // use null output function
    out = _out_null;
  401834:	48 8d 05 3c f9 ff ff 	lea    -0x6c4(%rip),%rax        # 401177 <_out_null>
  40183b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  }

  while (*format)
  40183f:	e9 d5 0d 00 00       	jmp    402619 <_vsnprintf+0xe14>
  {
    // format specifier?  %[flags][width][.precision][length]
    if (*format != '%') {
  401844:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401848:	0f b6 00             	movzbl (%rax),%eax
  40184b:	3c 25                	cmp    $0x25,%al
  40184d:	74 3c                	je     40188b <_vsnprintf+0x86>
      // no
      out(*format, buffer, idx++, maxlen);
  40184f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401853:	48 8d 50 01          	lea    0x1(%rax),%rdx
  401857:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  40185b:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  40185f:	0f b6 12             	movzbl (%rdx),%edx
  401862:	0f be fa             	movsbl %dl,%edi
  401865:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  401869:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  40186d:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
  401871:	48 89 d1             	mov    %rdx,%rcx
  401874:	48 89 c2             	mov    %rax,%rdx
  401877:	41 ff d0             	call   *%r8
      format++;
  40187a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  40187e:	48 83 c0 01          	add    $0x1,%rax
  401882:	48 89 45 90          	mov    %rax,-0x70(%rbp)
      continue;
  401886:	e9 8e 0d 00 00       	jmp    402619 <_vsnprintf+0xe14>
    }
    else {
      // yes, evaluate it
      format++;
  40188b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  40188f:	48 83 c0 01          	add    $0x1,%rax
  401893:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    }

    // evaluate flags
    flags = 0U;
  401897:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    do {
      switch (*format) {
  40189e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  4018a2:	0f b6 00             	movzbl (%rax),%eax
  4018a5:	0f be c0             	movsbl %al,%eax
  4018a8:	83 e8 20             	sub    $0x20,%eax
  4018ab:	83 f8 10             	cmp    $0x10,%eax
  4018ae:	0f 87 9f 00 00 00    	ja     401953 <_vsnprintf+0x14e>
  4018b4:	89 c0                	mov    %eax,%eax
  4018b6:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  4018bd:	00 
  4018be:	48 8d 05 bf 17 00 00 	lea    0x17bf(%rip),%rax        # 403084 <sbrk+0x29a>
  4018c5:	8b 04 02             	mov    (%rdx,%rax,1),%eax
  4018c8:	48 98                	cltq
  4018ca:	48 8d 15 b3 17 00 00 	lea    0x17b3(%rip),%rdx        # 403084 <sbrk+0x29a>
  4018d1:	48 01 d0             	add    %rdx,%rax
  4018d4:	ff e0                	jmp    *%rax
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
  4018d6:	83 4d fc 01          	orl    $0x1,-0x4(%rbp)
  4018da:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  4018de:	48 83 c0 01          	add    $0x1,%rax
  4018e2:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  4018e6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%rbp)
  4018ed:	eb 6c                	jmp    40195b <_vsnprintf+0x156>
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
  4018ef:	83 4d fc 02          	orl    $0x2,-0x4(%rbp)
  4018f3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  4018f7:	48 83 c0 01          	add    $0x1,%rax
  4018fb:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  4018ff:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%rbp)
  401906:	eb 53                	jmp    40195b <_vsnprintf+0x156>
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
  401908:	83 4d fc 04          	orl    $0x4,-0x4(%rbp)
  40190c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401910:	48 83 c0 01          	add    $0x1,%rax
  401914:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  401918:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%rbp)
  40191f:	eb 3a                	jmp    40195b <_vsnprintf+0x156>
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
  401921:	83 4d fc 08          	orl    $0x8,-0x4(%rbp)
  401925:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401929:	48 83 c0 01          	add    $0x1,%rax
  40192d:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  401931:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%rbp)
  401938:	eb 21                	jmp    40195b <_vsnprintf+0x156>
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
  40193a:	83 4d fc 10          	orl    $0x10,-0x4(%rbp)
  40193e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401942:	48 83 c0 01          	add    $0x1,%rax
  401946:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  40194a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%rbp)
  401951:	eb 08                	jmp    40195b <_vsnprintf+0x156>
        default :                                   n = 0U; break;
  401953:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  40195a:	90                   	nop
      }
    } while (n);
  40195b:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  40195f:	0f 85 39 ff ff ff    	jne    40189e <_vsnprintf+0x99>

    // evaluate width field
    width = 0U;
  401965:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
    if (_is_digit(*format)) {
  40196c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401970:	0f b6 00             	movzbl (%rax),%eax
  401973:	0f be c0             	movsbl %al,%eax
  401976:	89 c7                	mov    %eax,%edi
  401978:	e8 bc f8 ff ff       	call   401239 <_is_digit>
  40197d:	84 c0                	test   %al,%al
  40197f:	74 11                	je     401992 <_vsnprintf+0x18d>
      width = _atoi(&format);
  401981:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  401985:	48 89 c7             	mov    %rax,%rdi
  401988:	e8 d2 f8 ff ff       	call   40125f <_atoi>
  40198d:	89 45 f8             	mov    %eax,-0x8(%rbp)
  401990:	eb 79                	jmp    401a0b <_vsnprintf+0x206>
    }
    else if (*format == '*') {
  401992:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401996:	0f b6 00             	movzbl (%rax),%eax
  401999:	3c 2a                	cmp    $0x2a,%al
  40199b:	75 6e                	jne    401a0b <_vsnprintf+0x206>
      const int w = va_arg(va, int);
  40199d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4019a1:	8b 00                	mov    (%rax),%eax
  4019a3:	83 f8 2f             	cmp    $0x2f,%eax
  4019a6:	77 24                	ja     4019cc <_vsnprintf+0x1c7>
  4019a8:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4019ac:	48 8b 50 10          	mov    0x10(%rax),%rdx
  4019b0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4019b4:	8b 00                	mov    (%rax),%eax
  4019b6:	89 c0                	mov    %eax,%eax
  4019b8:	48 01 d0             	add    %rdx,%rax
  4019bb:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  4019bf:	8b 12                	mov    (%rdx),%edx
  4019c1:	8d 4a 08             	lea    0x8(%rdx),%ecx
  4019c4:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  4019c8:	89 0a                	mov    %ecx,(%rdx)
  4019ca:	eb 14                	jmp    4019e0 <_vsnprintf+0x1db>
  4019cc:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4019d0:	48 8b 40 08          	mov    0x8(%rax),%rax
  4019d4:	48 8d 48 08          	lea    0x8(%rax),%rcx
  4019d8:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  4019dc:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  4019e0:	8b 00                	mov    (%rax),%eax
  4019e2:	89 45 d0             	mov    %eax,-0x30(%rbp)
      if (w < 0) {
  4019e5:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  4019e9:	79 0e                	jns    4019f9 <_vsnprintf+0x1f4>
        flags |= FLAGS_LEFT;    // reverse padding
  4019eb:	83 4d fc 02          	orl    $0x2,-0x4(%rbp)
        width = (unsigned int)-w;
  4019ef:	8b 45 d0             	mov    -0x30(%rbp),%eax
  4019f2:	f7 d8                	neg    %eax
  4019f4:	89 45 f8             	mov    %eax,-0x8(%rbp)
  4019f7:	eb 06                	jmp    4019ff <_vsnprintf+0x1fa>
      }
      else {
        width = (unsigned int)w;
  4019f9:	8b 45 d0             	mov    -0x30(%rbp),%eax
  4019fc:	89 45 f8             	mov    %eax,-0x8(%rbp)
      }
      format++;
  4019ff:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401a03:	48 83 c0 01          	add    $0x1,%rax
  401a07:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    }

    // evaluate precision field
    precision = 0U;
  401a0b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    if (*format == '.') {
  401a12:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401a16:	0f b6 00             	movzbl (%rax),%eax
  401a19:	3c 2e                	cmp    $0x2e,%al
  401a1b:	0f 85 a8 00 00 00    	jne    401ac9 <_vsnprintf+0x2c4>
      flags |= FLAGS_PRECISION;
  401a21:	81 4d fc 00 04 00 00 	orl    $0x400,-0x4(%rbp)
      format++;
  401a28:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401a2c:	48 83 c0 01          	add    $0x1,%rax
  401a30:	48 89 45 90          	mov    %rax,-0x70(%rbp)
      if (_is_digit(*format)) {
  401a34:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401a38:	0f b6 00             	movzbl (%rax),%eax
  401a3b:	0f be c0             	movsbl %al,%eax
  401a3e:	89 c7                	mov    %eax,%edi
  401a40:	e8 f4 f7 ff ff       	call   401239 <_is_digit>
  401a45:	84 c0                	test   %al,%al
  401a47:	74 11                	je     401a5a <_vsnprintf+0x255>
        precision = _atoi(&format);
  401a49:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  401a4d:	48 89 c7             	mov    %rax,%rdi
  401a50:	e8 0a f8 ff ff       	call   40125f <_atoi>
  401a55:	89 45 f4             	mov    %eax,-0xc(%rbp)
  401a58:	eb 6f                	jmp    401ac9 <_vsnprintf+0x2c4>
      }
      else if (*format == '*') {
  401a5a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401a5e:	0f b6 00             	movzbl (%rax),%eax
  401a61:	3c 2a                	cmp    $0x2a,%al
  401a63:	75 64                	jne    401ac9 <_vsnprintf+0x2c4>
        const int prec = (int)va_arg(va, int);
  401a65:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401a69:	8b 00                	mov    (%rax),%eax
  401a6b:	83 f8 2f             	cmp    $0x2f,%eax
  401a6e:	77 24                	ja     401a94 <_vsnprintf+0x28f>
  401a70:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401a74:	48 8b 50 10          	mov    0x10(%rax),%rdx
  401a78:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401a7c:	8b 00                	mov    (%rax),%eax
  401a7e:	89 c0                	mov    %eax,%eax
  401a80:	48 01 d0             	add    %rdx,%rax
  401a83:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401a87:	8b 12                	mov    (%rdx),%edx
  401a89:	8d 4a 08             	lea    0x8(%rdx),%ecx
  401a8c:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401a90:	89 0a                	mov    %ecx,(%rdx)
  401a92:	eb 14                	jmp    401aa8 <_vsnprintf+0x2a3>
  401a94:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401a98:	48 8b 40 08          	mov    0x8(%rax),%rax
  401a9c:	48 8d 48 08          	lea    0x8(%rax),%rcx
  401aa0:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401aa4:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  401aa8:	8b 00                	mov    (%rax),%eax
  401aaa:	89 45 cc             	mov    %eax,-0x34(%rbp)
        precision = prec > 0 ? (unsigned int)prec : 0U;
  401aad:	8b 45 cc             	mov    -0x34(%rbp),%eax
  401ab0:	ba 00 00 00 00       	mov    $0x0,%edx
  401ab5:	85 c0                	test   %eax,%eax
  401ab7:	0f 48 c2             	cmovs  %edx,%eax
  401aba:	89 45 f4             	mov    %eax,-0xc(%rbp)
        format++;
  401abd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401ac1:	48 83 c0 01          	add    $0x1,%rax
  401ac5:	48 89 45 90          	mov    %rax,-0x70(%rbp)
      }
    }

    // evaluate length field
    switch (*format) {
  401ac9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401acd:	0f b6 00             	movzbl (%rax),%eax
  401ad0:	0f be c0             	movsbl %al,%eax
  401ad3:	83 e8 68             	sub    $0x68,%eax
  401ad6:	83 f8 12             	cmp    $0x12,%eax
  401ad9:	0f 87 c8 00 00 00    	ja     401ba7 <_vsnprintf+0x3a2>
  401adf:	89 c0                	mov    %eax,%eax
  401ae1:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  401ae8:	00 
  401ae9:	48 8d 05 d8 15 00 00 	lea    0x15d8(%rip),%rax        # 4030c8 <sbrk+0x2de>
  401af0:	8b 04 02             	mov    (%rdx,%rax,1),%eax
  401af3:	48 98                	cltq
  401af5:	48 8d 15 cc 15 00 00 	lea    0x15cc(%rip),%rdx        # 4030c8 <sbrk+0x2de>
  401afc:	48 01 d0             	add    %rdx,%rax
  401aff:	ff e0                	jmp    *%rax
      case 'l' :
        flags |= FLAGS_LONG;
  401b01:	81 4d fc 00 01 00 00 	orl    $0x100,-0x4(%rbp)
        format++;
  401b08:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401b0c:	48 83 c0 01          	add    $0x1,%rax
  401b10:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        if (*format == 'l') {
  401b14:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401b18:	0f b6 00             	movzbl (%rax),%eax
  401b1b:	3c 6c                	cmp    $0x6c,%al
  401b1d:	0f 85 87 00 00 00    	jne    401baa <_vsnprintf+0x3a5>
          flags |= FLAGS_LONG_LONG;
  401b23:	81 4d fc 00 02 00 00 	orl    $0x200,-0x4(%rbp)
          format++;
  401b2a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401b2e:	48 83 c0 01          	add    $0x1,%rax
  401b32:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        }
        break;
  401b36:	eb 72                	jmp    401baa <_vsnprintf+0x3a5>
      case 'h' :
        flags |= FLAGS_SHORT;
  401b38:	81 4d fc 80 00 00 00 	orl    $0x80,-0x4(%rbp)
        format++;
  401b3f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401b43:	48 83 c0 01          	add    $0x1,%rax
  401b47:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        if (*format == 'h') {
  401b4b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401b4f:	0f b6 00             	movzbl (%rax),%eax
  401b52:	3c 68                	cmp    $0x68,%al
  401b54:	75 57                	jne    401bad <_vsnprintf+0x3a8>
          flags |= FLAGS_CHAR;
  401b56:	83 4d fc 40          	orl    $0x40,-0x4(%rbp)
          format++;
  401b5a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401b5e:	48 83 c0 01          	add    $0x1,%rax
  401b62:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        }
        break;
  401b66:	eb 45                	jmp    401bad <_vsnprintf+0x3a8>
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
      case 't' :
        flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
  401b68:	81 4d fc 00 01 00 00 	orl    $0x100,-0x4(%rbp)
        format++;
  401b6f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401b73:	48 83 c0 01          	add    $0x1,%rax
  401b77:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        break;
  401b7b:	eb 31                	jmp    401bae <_vsnprintf+0x3a9>
#endif
      case 'j' :
        flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
  401b7d:	81 4d fc 00 01 00 00 	orl    $0x100,-0x4(%rbp)
        format++;
  401b84:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401b88:	48 83 c0 01          	add    $0x1,%rax
  401b8c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        break;
  401b90:	eb 1c                	jmp    401bae <_vsnprintf+0x3a9>
      case 'z' :
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
  401b92:	81 4d fc 00 01 00 00 	orl    $0x100,-0x4(%rbp)
        format++;
  401b99:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401b9d:	48 83 c0 01          	add    $0x1,%rax
  401ba1:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        break;
  401ba5:	eb 07                	jmp    401bae <_vsnprintf+0x3a9>
      default :
        break;
  401ba7:	90                   	nop
  401ba8:	eb 04                	jmp    401bae <_vsnprintf+0x3a9>
        break;
  401baa:	90                   	nop
  401bab:	eb 01                	jmp    401bae <_vsnprintf+0x3a9>
        break;
  401bad:	90                   	nop
    }

    // evaluate specifier
    switch (*format) {
  401bae:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401bb2:	0f b6 00             	movzbl (%rax),%eax
  401bb5:	0f be c0             	movsbl %al,%eax
  401bb8:	83 f8 78             	cmp    $0x78,%eax
  401bbb:	0f 8f 20 0a 00 00    	jg     4025e1 <_vsnprintf+0xddc>
  401bc1:	83 f8 64             	cmp    $0x64,%eax
  401bc4:	7d 33                	jge    401bf9 <_vsnprintf+0x3f4>
  401bc6:	83 f8 63             	cmp    $0x63,%eax
  401bc9:	0f 84 50 06 00 00    	je     40221f <_vsnprintf+0xa1a>
  401bcf:	83 f8 63             	cmp    $0x63,%eax
  401bd2:	0f 8f 09 0a 00 00    	jg     4025e1 <_vsnprintf+0xddc>
  401bd8:	83 f8 62             	cmp    $0x62,%eax
  401bdb:	74 6e                	je     401c4b <_vsnprintf+0x446>
  401bdd:	83 f8 62             	cmp    $0x62,%eax
  401be0:	0f 8f fb 09 00 00    	jg     4025e1 <_vsnprintf+0xddc>
  401be6:	83 f8 25             	cmp    $0x25,%eax
  401be9:	0f 84 be 09 00 00    	je     4025ad <_vsnprintf+0xda8>
  401bef:	83 f8 58             	cmp    $0x58,%eax
  401bf2:	74 57                	je     401c4b <_vsnprintf+0x446>
  401bf4:	e9 e8 09 00 00       	jmp    4025e1 <_vsnprintf+0xddc>
  401bf9:	83 e8 64             	sub    $0x64,%eax
  401bfc:	ba 01 00 00 00       	mov    $0x1,%edx
  401c01:	89 c1                	mov    %eax,%ecx
  401c03:	48 d3 e2             	shl    %cl,%rdx
  401c06:	48 89 d0             	mov    %rdx,%rax
  401c09:	48 89 c2             	mov    %rax,%rdx
  401c0c:	81 e2 21 08 12 00    	and    $0x120821,%edx
  401c12:	48 85 d2             	test   %rdx,%rdx
  401c15:	0f 95 c2             	setne  %dl
  401c18:	84 d2                	test   %dl,%dl
  401c1a:	75 2f                	jne    401c4b <_vsnprintf+0x446>
  401c1c:	48 89 c2             	mov    %rax,%rdx
  401c1f:	81 e2 00 10 00 00    	and    $0x1000,%edx
  401c25:	48 85 d2             	test   %rdx,%rdx
  401c28:	0f 95 c2             	setne  %dl
  401c2b:	84 d2                	test   %dl,%dl
  401c2d:	0f 85 5b 08 00 00    	jne    40248e <_vsnprintf+0xc89>
  401c33:	25 00 80 00 00       	and    $0x8000,%eax
  401c38:	48 85 c0             	test   %rax,%rax
  401c3b:	0f 95 c0             	setne  %al
  401c3e:	84 c0                	test   %al,%al
  401c40:	0f 85 d6 06 00 00    	jne    40231c <_vsnprintf+0xb17>
  401c46:	e9 96 09 00 00       	jmp    4025e1 <_vsnprintf+0xddc>
      case 'X' :
      case 'o' :
      case 'b' : {
        // set the base
        unsigned int base;
        if (*format == 'x' || *format == 'X') {
  401c4b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401c4f:	0f b6 00             	movzbl (%rax),%eax
  401c52:	3c 78                	cmp    $0x78,%al
  401c54:	74 0b                	je     401c61 <_vsnprintf+0x45c>
  401c56:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401c5a:	0f b6 00             	movzbl (%rax),%eax
  401c5d:	3c 58                	cmp    $0x58,%al
  401c5f:	75 09                	jne    401c6a <_vsnprintf+0x465>
          base = 16U;
  401c61:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
  401c68:	eb 33                	jmp    401c9d <_vsnprintf+0x498>
        }
        else if (*format == 'o') {
  401c6a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401c6e:	0f b6 00             	movzbl (%rax),%eax
  401c71:	3c 6f                	cmp    $0x6f,%al
  401c73:	75 09                	jne    401c7e <_vsnprintf+0x479>
          base =  8U;
  401c75:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
  401c7c:	eb 1f                	jmp    401c9d <_vsnprintf+0x498>
        }
        else if (*format == 'b') {
  401c7e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401c82:	0f b6 00             	movzbl (%rax),%eax
  401c85:	3c 62                	cmp    $0x62,%al
  401c87:	75 09                	jne    401c92 <_vsnprintf+0x48d>
          base =  2U;
  401c89:	c7 45 e4 02 00 00 00 	movl   $0x2,-0x1c(%rbp)
  401c90:	eb 0b                	jmp    401c9d <_vsnprintf+0x498>
        }
        else {
          base = 10U;
  401c92:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
          flags &= ~FLAGS_HASH;   // no hash for dec format
  401c99:	83 65 fc ef          	andl   $0xffffffef,-0x4(%rbp)
        }
        // uppercase
        if (*format == 'X') {
  401c9d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401ca1:	0f b6 00             	movzbl (%rax),%eax
  401ca4:	3c 58                	cmp    $0x58,%al
  401ca6:	75 04                	jne    401cac <_vsnprintf+0x4a7>
          flags |= FLAGS_UPPERCASE;
  401ca8:	83 4d fc 20          	orl    $0x20,-0x4(%rbp)
        }

        // no plus or space flag for u, x, X, o, b
        if ((*format != 'i') && (*format != 'd')) {
  401cac:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401cb0:	0f b6 00             	movzbl (%rax),%eax
  401cb3:	3c 69                	cmp    $0x69,%al
  401cb5:	74 0f                	je     401cc6 <_vsnprintf+0x4c1>
  401cb7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401cbb:	0f b6 00             	movzbl (%rax),%eax
  401cbe:	3c 64                	cmp    $0x64,%al
  401cc0:	74 04                	je     401cc6 <_vsnprintf+0x4c1>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  401cc2:	83 65 fc f3          	andl   $0xfffffff3,-0x4(%rbp)
        }

        // ignore '0' flag when precision is given
        if (flags & FLAGS_PRECISION) {
  401cc6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401cc9:	25 00 04 00 00       	and    $0x400,%eax
  401cce:	85 c0                	test   %eax,%eax
  401cd0:	74 04                	je     401cd6 <_vsnprintf+0x4d1>
          flags &= ~FLAGS_ZEROPAD;
  401cd2:	83 65 fc fe          	andl   $0xfffffffe,-0x4(%rbp)
        }

        // convert the integer
        if ((*format == 'i') || (*format == 'd')) {
  401cd6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401cda:	0f b6 00             	movzbl (%rax),%eax
  401cdd:	3c 69                	cmp    $0x69,%al
  401cdf:	74 0f                	je     401cf0 <_vsnprintf+0x4eb>
  401ce1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  401ce5:	0f b6 00             	movzbl (%rax),%eax
  401ce8:	3c 64                	cmp    $0x64,%al
  401cea:	0f 85 b2 02 00 00    	jne    401fa2 <_vsnprintf+0x79d>
          // signed
          if (flags & FLAGS_LONG_LONG) {
  401cf0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401cf3:	25 00 02 00 00       	and    $0x200,%eax
  401cf8:	85 c0                	test   %eax,%eax
  401cfa:	0f 84 a5 00 00 00    	je     401da5 <_vsnprintf+0x5a0>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            const long long value = va_arg(va, long long);
  401d00:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401d04:	8b 00                	mov    (%rax),%eax
  401d06:	83 f8 2f             	cmp    $0x2f,%eax
  401d09:	77 24                	ja     401d2f <_vsnprintf+0x52a>
  401d0b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401d0f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  401d13:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401d17:	8b 00                	mov    (%rax),%eax
  401d19:	89 c0                	mov    %eax,%eax
  401d1b:	48 01 d0             	add    %rdx,%rax
  401d1e:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401d22:	8b 12                	mov    (%rdx),%edx
  401d24:	8d 4a 08             	lea    0x8(%rdx),%ecx
  401d27:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401d2b:	89 0a                	mov    %ecx,(%rdx)
  401d2d:	eb 14                	jmp    401d43 <_vsnprintf+0x53e>
  401d2f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401d33:	48 8b 40 08          	mov    0x8(%rax),%rax
  401d37:	48 8d 48 08          	lea    0x8(%rax),%rcx
  401d3b:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401d3f:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  401d43:	48 8b 00             	mov    (%rax),%rax
  401d46:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  401d4a:	8b 7d e4             	mov    -0x1c(%rbp),%edi
  401d4d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  401d51:	48 c1 e8 3f          	shr    $0x3f,%rax
  401d55:	44 0f b6 c8          	movzbl %al,%r9d
  401d59:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  401d5d:	48 89 c2             	mov    %rax,%rdx
  401d60:	48 f7 da             	neg    %rdx
  401d63:	48 0f 49 c2          	cmovns %rdx,%rax
  401d67:	49 89 c2             	mov    %rax,%r10
  401d6a:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  401d6e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401d72:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  401d76:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  401d7a:	44 8b 45 fc          	mov    -0x4(%rbp),%r8d
  401d7e:	41 50                	push   %r8
  401d80:	44 8b 45 f8          	mov    -0x8(%rbp),%r8d
  401d84:	41 50                	push   %r8
  401d86:	44 8b 45 f4          	mov    -0xc(%rbp),%r8d
  401d8a:	41 50                	push   %r8
  401d8c:	57                   	push   %rdi
  401d8d:	4d 89 d0             	mov    %r10,%r8
  401d90:	48 89 c7             	mov    %rax,%rdi
  401d93:	e8 64 f9 ff ff       	call   4016fc <_ntoa_long_long>
  401d98:	48 83 c4 20          	add    $0x20,%rsp
  401d9c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
          if (flags & FLAGS_LONG_LONG) {
  401da0:	e9 69 04 00 00       	jmp    40220e <_vsnprintf+0xa09>
#endif
          }
          else if (flags & FLAGS_LONG) {
  401da5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401da8:	25 00 01 00 00       	and    $0x100,%eax
  401dad:	85 c0                	test   %eax,%eax
  401daf:	0f 84 a5 00 00 00    	je     401e5a <_vsnprintf+0x655>
            const long value = va_arg(va, long);
  401db5:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401db9:	8b 00                	mov    (%rax),%eax
  401dbb:	83 f8 2f             	cmp    $0x2f,%eax
  401dbe:	77 24                	ja     401de4 <_vsnprintf+0x5df>
  401dc0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401dc4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  401dc8:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401dcc:	8b 00                	mov    (%rax),%eax
  401dce:	89 c0                	mov    %eax,%eax
  401dd0:	48 01 d0             	add    %rdx,%rax
  401dd3:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401dd7:	8b 12                	mov    (%rdx),%edx
  401dd9:	8d 4a 08             	lea    0x8(%rdx),%ecx
  401ddc:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401de0:	89 0a                	mov    %ecx,(%rdx)
  401de2:	eb 14                	jmp    401df8 <_vsnprintf+0x5f3>
  401de4:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401de8:	48 8b 40 08          	mov    0x8(%rax),%rax
  401dec:	48 8d 48 08          	lea    0x8(%rax),%rcx
  401df0:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401df4:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  401df8:	48 8b 00             	mov    (%rax),%rax
  401dfb:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  401dff:	8b 7d e4             	mov    -0x1c(%rbp),%edi
  401e02:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  401e06:	48 c1 e8 3f          	shr    $0x3f,%rax
  401e0a:	44 0f b6 c8          	movzbl %al,%r9d
  401e0e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  401e12:	48 89 c2             	mov    %rax,%rdx
  401e15:	48 f7 da             	neg    %rdx
  401e18:	48 0f 49 c2          	cmovns %rdx,%rax
  401e1c:	49 89 c2             	mov    %rax,%r10
  401e1f:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  401e23:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401e27:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  401e2b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  401e2f:	44 8b 45 fc          	mov    -0x4(%rbp),%r8d
  401e33:	41 50                	push   %r8
  401e35:	44 8b 45 f8          	mov    -0x8(%rbp),%r8d
  401e39:	41 50                	push   %r8
  401e3b:	44 8b 45 f4          	mov    -0xc(%rbp),%r8d
  401e3f:	41 50                	push   %r8
  401e41:	57                   	push   %rdi
  401e42:	4d 89 d0             	mov    %r10,%r8
  401e45:	48 89 c7             	mov    %rax,%rdi
  401e48:	e8 a6 f7 ff ff       	call   4015f3 <_ntoa_long>
  401e4d:	48 83 c4 20          	add    $0x20,%rsp
  401e51:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
          if (flags & FLAGS_LONG_LONG) {
  401e55:	e9 b4 03 00 00       	jmp    40220e <_vsnprintf+0xa09>
          }
          else {
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  401e5a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401e5d:	83 e0 40             	and    $0x40,%eax
  401e60:	85 c0                	test   %eax,%eax
  401e62:	74 4d                	je     401eb1 <_vsnprintf+0x6ac>
  401e64:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401e68:	8b 00                	mov    (%rax),%eax
  401e6a:	83 f8 2f             	cmp    $0x2f,%eax
  401e6d:	77 24                	ja     401e93 <_vsnprintf+0x68e>
  401e6f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401e73:	48 8b 50 10          	mov    0x10(%rax),%rdx
  401e77:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401e7b:	8b 00                	mov    (%rax),%eax
  401e7d:	89 c0                	mov    %eax,%eax
  401e7f:	48 01 d0             	add    %rdx,%rax
  401e82:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401e86:	8b 12                	mov    (%rdx),%edx
  401e88:	8d 4a 08             	lea    0x8(%rdx),%ecx
  401e8b:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401e8f:	89 0a                	mov    %ecx,(%rdx)
  401e91:	eb 14                	jmp    401ea7 <_vsnprintf+0x6a2>
  401e93:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401e97:	48 8b 40 08          	mov    0x8(%rax),%rax
  401e9b:	48 8d 48 08          	lea    0x8(%rax),%rcx
  401e9f:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401ea3:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  401ea7:	8b 00                	mov    (%rax),%eax
  401ea9:	0f be c0             	movsbl %al,%eax
  401eac:	e9 99 00 00 00       	jmp    401f4a <_vsnprintf+0x745>
  401eb1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401eb4:	25 80 00 00 00       	and    $0x80,%eax
  401eb9:	85 c0                	test   %eax,%eax
  401ebb:	74 48                	je     401f05 <_vsnprintf+0x700>
  401ebd:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401ec1:	8b 00                	mov    (%rax),%eax
  401ec3:	83 f8 2f             	cmp    $0x2f,%eax
  401ec6:	77 24                	ja     401eec <_vsnprintf+0x6e7>
  401ec8:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401ecc:	48 8b 50 10          	mov    0x10(%rax),%rdx
  401ed0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401ed4:	8b 00                	mov    (%rax),%eax
  401ed6:	89 c0                	mov    %eax,%eax
  401ed8:	48 01 d0             	add    %rdx,%rax
  401edb:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401edf:	8b 12                	mov    (%rdx),%edx
  401ee1:	8d 4a 08             	lea    0x8(%rdx),%ecx
  401ee4:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401ee8:	89 0a                	mov    %ecx,(%rdx)
  401eea:	eb 14                	jmp    401f00 <_vsnprintf+0x6fb>
  401eec:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401ef0:	48 8b 40 08          	mov    0x8(%rax),%rax
  401ef4:	48 8d 48 08          	lea    0x8(%rax),%rcx
  401ef8:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401efc:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  401f00:	8b 00                	mov    (%rax),%eax
  401f02:	98                   	cwtl
  401f03:	eb 45                	jmp    401f4a <_vsnprintf+0x745>
  401f05:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401f09:	8b 00                	mov    (%rax),%eax
  401f0b:	83 f8 2f             	cmp    $0x2f,%eax
  401f0e:	77 24                	ja     401f34 <_vsnprintf+0x72f>
  401f10:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401f14:	48 8b 50 10          	mov    0x10(%rax),%rdx
  401f18:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401f1c:	8b 00                	mov    (%rax),%eax
  401f1e:	89 c0                	mov    %eax,%eax
  401f20:	48 01 d0             	add    %rdx,%rax
  401f23:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401f27:	8b 12                	mov    (%rdx),%edx
  401f29:	8d 4a 08             	lea    0x8(%rdx),%ecx
  401f2c:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401f30:	89 0a                	mov    %ecx,(%rdx)
  401f32:	eb 14                	jmp    401f48 <_vsnprintf+0x743>
  401f34:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401f38:	48 8b 40 08          	mov    0x8(%rax),%rax
  401f3c:	48 8d 48 08          	lea    0x8(%rax),%rcx
  401f40:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401f44:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  401f48:	8b 00                	mov    (%rax),%eax
  401f4a:	89 45 c0             	mov    %eax,-0x40(%rbp)
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  401f4d:	8b 7d e4             	mov    -0x1c(%rbp),%edi
  401f50:	8b 45 c0             	mov    -0x40(%rbp),%eax
  401f53:	c1 e8 1f             	shr    $0x1f,%eax
  401f56:	44 0f b6 c8          	movzbl %al,%r9d
  401f5a:	8b 45 c0             	mov    -0x40(%rbp),%eax
  401f5d:	89 c2                	mov    %eax,%edx
  401f5f:	f7 da                	neg    %edx
  401f61:	0f 49 c2             	cmovns %edx,%eax
  401f64:	41 89 c2             	mov    %eax,%r10d
  401f67:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  401f6b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401f6f:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  401f73:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  401f77:	44 8b 45 fc          	mov    -0x4(%rbp),%r8d
  401f7b:	41 50                	push   %r8
  401f7d:	44 8b 45 f8          	mov    -0x8(%rbp),%r8d
  401f81:	41 50                	push   %r8
  401f83:	44 8b 45 f4          	mov    -0xc(%rbp),%r8d
  401f87:	41 50                	push   %r8
  401f89:	57                   	push   %rdi
  401f8a:	4d 89 d0             	mov    %r10,%r8
  401f8d:	48 89 c7             	mov    %rax,%rdi
  401f90:	e8 5e f6 ff ff       	call   4015f3 <_ntoa_long>
  401f95:	48 83 c4 20          	add    $0x20,%rsp
  401f99:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
          if (flags & FLAGS_LONG_LONG) {
  401f9d:	e9 6c 02 00 00       	jmp    40220e <_vsnprintf+0xa09>
          }
        }
        else {
          // unsigned
          if (flags & FLAGS_LONG_LONG) {
  401fa2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401fa5:	25 00 02 00 00       	and    $0x200,%eax
  401faa:	85 c0                	test   %eax,%eax
  401fac:	0f 84 8a 00 00 00    	je     40203c <_vsnprintf+0x837>
#if defined(PRINTF_SUPPORT_LONG_LONG)
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  401fb2:	8b 7d e4             	mov    -0x1c(%rbp),%edi
  401fb5:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401fb9:	8b 00                	mov    (%rax),%eax
  401fbb:	83 f8 2f             	cmp    $0x2f,%eax
  401fbe:	77 24                	ja     401fe4 <_vsnprintf+0x7df>
  401fc0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401fc4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  401fc8:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401fcc:	8b 00                	mov    (%rax),%eax
  401fce:	89 c0                	mov    %eax,%eax
  401fd0:	48 01 d0             	add    %rdx,%rax
  401fd3:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401fd7:	8b 12                	mov    (%rdx),%edx
  401fd9:	8d 4a 08             	lea    0x8(%rdx),%ecx
  401fdc:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401fe0:	89 0a                	mov    %ecx,(%rdx)
  401fe2:	eb 14                	jmp    401ff8 <_vsnprintf+0x7f3>
  401fe4:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  401fe8:	48 8b 40 08          	mov    0x8(%rax),%rax
  401fec:	48 8d 48 08          	lea    0x8(%rax),%rcx
  401ff0:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  401ff4:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  401ff8:	4c 8b 10             	mov    (%rax),%r10
  401ffb:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  401fff:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402003:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  402007:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  40200b:	44 8b 45 fc          	mov    -0x4(%rbp),%r8d
  40200f:	41 50                	push   %r8
  402011:	44 8b 45 f8          	mov    -0x8(%rbp),%r8d
  402015:	41 50                	push   %r8
  402017:	44 8b 45 f4          	mov    -0xc(%rbp),%r8d
  40201b:	41 50                	push   %r8
  40201d:	57                   	push   %rdi
  40201e:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  402024:	4d 89 d0             	mov    %r10,%r8
  402027:	48 89 c7             	mov    %rax,%rdi
  40202a:	e8 cd f6 ff ff       	call   4016fc <_ntoa_long_long>
  40202f:	48 83 c4 20          	add    $0x20,%rsp
  402033:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  402037:	e9 d2 01 00 00       	jmp    40220e <_vsnprintf+0xa09>
#endif
          }
          else if (flags & FLAGS_LONG) {
  40203c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40203f:	25 00 01 00 00       	and    $0x100,%eax
  402044:	85 c0                	test   %eax,%eax
  402046:	0f 84 8a 00 00 00    	je     4020d6 <_vsnprintf+0x8d1>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  40204c:	8b 7d e4             	mov    -0x1c(%rbp),%edi
  40204f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402053:	8b 00                	mov    (%rax),%eax
  402055:	83 f8 2f             	cmp    $0x2f,%eax
  402058:	77 24                	ja     40207e <_vsnprintf+0x879>
  40205a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  40205e:	48 8b 50 10          	mov    0x10(%rax),%rdx
  402062:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402066:	8b 00                	mov    (%rax),%eax
  402068:	89 c0                	mov    %eax,%eax
  40206a:	48 01 d0             	add    %rdx,%rax
  40206d:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  402071:	8b 12                	mov    (%rdx),%edx
  402073:	8d 4a 08             	lea    0x8(%rdx),%ecx
  402076:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  40207a:	89 0a                	mov    %ecx,(%rdx)
  40207c:	eb 14                	jmp    402092 <_vsnprintf+0x88d>
  40207e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402082:	48 8b 40 08          	mov    0x8(%rax),%rax
  402086:	48 8d 48 08          	lea    0x8(%rax),%rcx
  40208a:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  40208e:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  402092:	4c 8b 10             	mov    (%rax),%r10
  402095:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  402099:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  40209d:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  4020a1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  4020a5:	44 8b 45 fc          	mov    -0x4(%rbp),%r8d
  4020a9:	41 50                	push   %r8
  4020ab:	44 8b 45 f8          	mov    -0x8(%rbp),%r8d
  4020af:	41 50                	push   %r8
  4020b1:	44 8b 45 f4          	mov    -0xc(%rbp),%r8d
  4020b5:	41 50                	push   %r8
  4020b7:	57                   	push   %rdi
  4020b8:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  4020be:	4d 89 d0             	mov    %r10,%r8
  4020c1:	48 89 c7             	mov    %rax,%rdi
  4020c4:	e8 2a f5 ff ff       	call   4015f3 <_ntoa_long>
  4020c9:	48 83 c4 20          	add    $0x20,%rsp
  4020cd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  4020d1:	e9 38 01 00 00       	jmp    40220e <_vsnprintf+0xa09>
          }
          else {
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  4020d6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4020d9:	83 e0 40             	and    $0x40,%eax
  4020dc:	85 c0                	test   %eax,%eax
  4020de:	74 4d                	je     40212d <_vsnprintf+0x928>
  4020e0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4020e4:	8b 00                	mov    (%rax),%eax
  4020e6:	83 f8 2f             	cmp    $0x2f,%eax
  4020e9:	77 24                	ja     40210f <_vsnprintf+0x90a>
  4020eb:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4020ef:	48 8b 50 10          	mov    0x10(%rax),%rdx
  4020f3:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4020f7:	8b 00                	mov    (%rax),%eax
  4020f9:	89 c0                	mov    %eax,%eax
  4020fb:	48 01 d0             	add    %rdx,%rax
  4020fe:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  402102:	8b 12                	mov    (%rdx),%edx
  402104:	8d 4a 08             	lea    0x8(%rdx),%ecx
  402107:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  40210b:	89 0a                	mov    %ecx,(%rdx)
  40210d:	eb 14                	jmp    402123 <_vsnprintf+0x91e>
  40210f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402113:	48 8b 40 08          	mov    0x8(%rax),%rax
  402117:	48 8d 48 08          	lea    0x8(%rax),%rcx
  40211b:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  40211f:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  402123:	8b 00                	mov    (%rax),%eax
  402125:	0f b6 c0             	movzbl %al,%eax
  402128:	e9 9b 00 00 00       	jmp    4021c8 <_vsnprintf+0x9c3>
  40212d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402130:	25 80 00 00 00       	and    $0x80,%eax
  402135:	85 c0                	test   %eax,%eax
  402137:	74 4a                	je     402183 <_vsnprintf+0x97e>
  402139:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  40213d:	8b 00                	mov    (%rax),%eax
  40213f:	83 f8 2f             	cmp    $0x2f,%eax
  402142:	77 24                	ja     402168 <_vsnprintf+0x963>
  402144:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402148:	48 8b 50 10          	mov    0x10(%rax),%rdx
  40214c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402150:	8b 00                	mov    (%rax),%eax
  402152:	89 c0                	mov    %eax,%eax
  402154:	48 01 d0             	add    %rdx,%rax
  402157:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  40215b:	8b 12                	mov    (%rdx),%edx
  40215d:	8d 4a 08             	lea    0x8(%rdx),%ecx
  402160:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  402164:	89 0a                	mov    %ecx,(%rdx)
  402166:	eb 14                	jmp    40217c <_vsnprintf+0x977>
  402168:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  40216c:	48 8b 40 08          	mov    0x8(%rax),%rax
  402170:	48 8d 48 08          	lea    0x8(%rax),%rcx
  402174:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  402178:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  40217c:	8b 00                	mov    (%rax),%eax
  40217e:	0f b7 c0             	movzwl %ax,%eax
  402181:	eb 45                	jmp    4021c8 <_vsnprintf+0x9c3>
  402183:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402187:	8b 00                	mov    (%rax),%eax
  402189:	83 f8 2f             	cmp    $0x2f,%eax
  40218c:	77 24                	ja     4021b2 <_vsnprintf+0x9ad>
  40218e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402192:	48 8b 50 10          	mov    0x10(%rax),%rdx
  402196:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  40219a:	8b 00                	mov    (%rax),%eax
  40219c:	89 c0                	mov    %eax,%eax
  40219e:	48 01 d0             	add    %rdx,%rax
  4021a1:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  4021a5:	8b 12                	mov    (%rdx),%edx
  4021a7:	8d 4a 08             	lea    0x8(%rdx),%ecx
  4021aa:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  4021ae:	89 0a                	mov    %ecx,(%rdx)
  4021b0:	eb 14                	jmp    4021c6 <_vsnprintf+0x9c1>
  4021b2:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4021b6:	48 8b 40 08          	mov    0x8(%rax),%rax
  4021ba:	48 8d 48 08          	lea    0x8(%rax),%rcx
  4021be:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  4021c2:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  4021c6:	8b 00                	mov    (%rax),%eax
  4021c8:	89 45 c4             	mov    %eax,-0x3c(%rbp)
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
  4021cb:	8b 7d e4             	mov    -0x1c(%rbp),%edi
  4021ce:	44 8b 55 c4          	mov    -0x3c(%rbp),%r10d
  4021d2:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  4021d6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  4021da:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  4021de:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  4021e2:	44 8b 45 fc          	mov    -0x4(%rbp),%r8d
  4021e6:	41 50                	push   %r8
  4021e8:	44 8b 45 f8          	mov    -0x8(%rbp),%r8d
  4021ec:	41 50                	push   %r8
  4021ee:	44 8b 45 f4          	mov    -0xc(%rbp),%r8d
  4021f2:	41 50                	push   %r8
  4021f4:	57                   	push   %rdi
  4021f5:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  4021fb:	4d 89 d0             	mov    %r10,%r8
  4021fe:	48 89 c7             	mov    %rax,%rdi
  402201:	e8 ed f3 ff ff       	call   4015f3 <_ntoa_long>
  402206:	48 83 c4 20          	add    $0x20,%rsp
  40220a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
          }
        }
        format++;
  40220e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  402212:	48 83 c0 01          	add    $0x1,%rax
  402216:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        break;
  40221a:	e9 fa 03 00 00       	jmp    402619 <_vsnprintf+0xe14>
        format++;
        break;
#endif  // PRINTF_SUPPORT_EXPONENTIAL
#endif  // PRINTF_SUPPORT_FLOAT
      case 'c' : {
        unsigned int l = 1U;
  40221f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
        // pre padding
        if (!(flags & FLAGS_LEFT)) {
  402226:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402229:	83 e0 02             	and    $0x2,%eax
  40222c:	85 c0                	test   %eax,%eax
  40222e:	75 36                	jne    402266 <_vsnprintf+0xa61>
          while (l++ < width) {
  402230:	eb 26                	jmp    402258 <_vsnprintf+0xa53>
            out(' ', buffer, idx++, maxlen);
  402232:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402236:	48 8d 50 01          	lea    0x1(%rax),%rdx
  40223a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  40223e:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  402242:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  402246:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
  40224a:	48 89 d1             	mov    %rdx,%rcx
  40224d:	48 89 c2             	mov    %rax,%rdx
  402250:	bf 20 00 00 00       	mov    $0x20,%edi
  402255:	41 ff d0             	call   *%r8
          while (l++ < width) {
  402258:	8b 45 e0             	mov    -0x20(%rbp),%eax
  40225b:	8d 50 01             	lea    0x1(%rax),%edx
  40225e:	89 55 e0             	mov    %edx,-0x20(%rbp)
  402261:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  402264:	72 cc                	jb     402232 <_vsnprintf+0xa2d>
          }
        }
        // char output
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  402266:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  40226a:	48 8d 42 01          	lea    0x1(%rdx),%rax
  40226e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  402272:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402276:	8b 00                	mov    (%rax),%eax
  402278:	83 f8 2f             	cmp    $0x2f,%eax
  40227b:	77 24                	ja     4022a1 <_vsnprintf+0xa9c>
  40227d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402281:	48 8b 48 10          	mov    0x10(%rax),%rcx
  402285:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402289:	8b 00                	mov    (%rax),%eax
  40228b:	89 c0                	mov    %eax,%eax
  40228d:	48 01 c8             	add    %rcx,%rax
  402290:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  402294:	8b 09                	mov    (%rcx),%ecx
  402296:	8d 71 08             	lea    0x8(%rcx),%esi
  402299:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  40229d:	89 31                	mov    %esi,(%rcx)
  40229f:	eb 14                	jmp    4022b5 <_vsnprintf+0xab0>
  4022a1:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4022a5:	48 8b 40 08          	mov    0x8(%rax),%rax
  4022a9:	48 8d 70 08          	lea    0x8(%rax),%rsi
  4022ad:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  4022b1:	48 89 71 08          	mov    %rsi,0x8(%rcx)
  4022b5:	8b 00                	mov    (%rax),%eax
  4022b7:	0f be c0             	movsbl %al,%eax
  4022ba:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  4022be:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  4022c2:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
  4022c6:	89 c7                	mov    %eax,%edi
  4022c8:	41 ff d0             	call   *%r8
        // post padding
        if (flags & FLAGS_LEFT) {
  4022cb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4022ce:	83 e0 02             	and    $0x2,%eax
  4022d1:	85 c0                	test   %eax,%eax
  4022d3:	74 36                	je     40230b <_vsnprintf+0xb06>
          while (l++ < width) {
  4022d5:	eb 26                	jmp    4022fd <_vsnprintf+0xaf8>
            out(' ', buffer, idx++, maxlen);
  4022d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4022db:	48 8d 50 01          	lea    0x1(%rax),%rdx
  4022df:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  4022e3:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  4022e7:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  4022eb:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
  4022ef:	48 89 d1             	mov    %rdx,%rcx
  4022f2:	48 89 c2             	mov    %rax,%rdx
  4022f5:	bf 20 00 00 00       	mov    $0x20,%edi
  4022fa:	41 ff d0             	call   *%r8
          while (l++ < width) {
  4022fd:	8b 45 e0             	mov    -0x20(%rbp),%eax
  402300:	8d 50 01             	lea    0x1(%rax),%edx
  402303:	89 55 e0             	mov    %edx,-0x20(%rbp)
  402306:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  402309:	72 cc                	jb     4022d7 <_vsnprintf+0xad2>
          }
        }
        format++;
  40230b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  40230f:	48 83 c0 01          	add    $0x1,%rax
  402313:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        break;
  402317:	e9 fd 02 00 00       	jmp    402619 <_vsnprintf+0xe14>
      }

      case 's' : {
        const char* p = va_arg(va, char*);
  40231c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402320:	8b 00                	mov    (%rax),%eax
  402322:	83 f8 2f             	cmp    $0x2f,%eax
  402325:	77 24                	ja     40234b <_vsnprintf+0xb46>
  402327:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  40232b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  40232f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402333:	8b 00                	mov    (%rax),%eax
  402335:	89 c0                	mov    %eax,%eax
  402337:	48 01 d0             	add    %rdx,%rax
  40233a:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  40233e:	8b 12                	mov    (%rdx),%edx
  402340:	8d 4a 08             	lea    0x8(%rdx),%ecx
  402343:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  402347:	89 0a                	mov    %ecx,(%rdx)
  402349:	eb 14                	jmp    40235f <_vsnprintf+0xb5a>
  40234b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  40234f:	48 8b 40 08          	mov    0x8(%rax),%rax
  402353:	48 8d 48 08          	lea    0x8(%rax),%rcx
  402357:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  40235b:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  40235f:	48 8b 00             	mov    (%rax),%rax
  402362:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
  402366:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  40236a:	74 05                	je     402371 <_vsnprintf+0xb6c>
  40236c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  40236f:	eb 07                	jmp    402378 <_vsnprintf+0xb73>
  402371:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  402378:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  40237c:	48 89 c6             	mov    %rax,%rsi
  40237f:	48 89 d7             	mov    %rdx,%rdi
  402382:	e8 71 ee ff ff       	call   4011f8 <_strnlen_s>
  402387:	89 45 d4             	mov    %eax,-0x2c(%rbp)
        // pre padding
        if (flags & FLAGS_PRECISION) {
  40238a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40238d:	25 00 04 00 00       	and    $0x400,%eax
  402392:	85 c0                	test   %eax,%eax
  402394:	74 0e                	je     4023a4 <_vsnprintf+0xb9f>
          l = (l < precision ? l : precision);
  402396:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  402399:	8b 45 f4             	mov    -0xc(%rbp),%eax
  40239c:	39 c2                	cmp    %eax,%edx
  40239e:	0f 46 c2             	cmovbe %edx,%eax
  4023a1:	89 45 d4             	mov    %eax,-0x2c(%rbp)
        }
        if (!(flags & FLAGS_LEFT)) {
  4023a4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4023a7:	83 e0 02             	and    $0x2,%eax
  4023aa:	85 c0                	test   %eax,%eax
  4023ac:	75 6b                	jne    402419 <_vsnprintf+0xc14>
          while (l++ < width) {
  4023ae:	eb 26                	jmp    4023d6 <_vsnprintf+0xbd1>
            out(' ', buffer, idx++, maxlen);
  4023b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4023b4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  4023b8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  4023bc:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  4023c0:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  4023c4:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
  4023c8:	48 89 d1             	mov    %rdx,%rcx
  4023cb:	48 89 c2             	mov    %rax,%rdx
  4023ce:	bf 20 00 00 00       	mov    $0x20,%edi
  4023d3:	41 ff d0             	call   *%r8
          while (l++ < width) {
  4023d6:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  4023d9:	8d 50 01             	lea    0x1(%rax),%edx
  4023dc:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  4023df:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  4023e2:	72 cc                	jb     4023b0 <_vsnprintf+0xbab>
          }
        }
        // string output
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  4023e4:	eb 33                	jmp    402419 <_vsnprintf+0xc14>
          out(*(p++), buffer, idx++, maxlen);
  4023e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4023ea:	48 8d 50 01          	lea    0x1(%rax),%rdx
  4023ee:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  4023f2:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  4023f6:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  4023fa:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  4023fe:	0f b6 12             	movzbl (%rdx),%edx
  402401:	0f be fa             	movsbl %dl,%edi
  402404:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  402408:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  40240c:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
  402410:	48 89 d1             	mov    %rdx,%rcx
  402413:	48 89 c2             	mov    %rax,%rdx
  402416:	41 ff d0             	call   *%r8
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  402419:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40241d:	0f b6 00             	movzbl (%rax),%eax
  402420:	84 c0                	test   %al,%al
  402422:	74 19                	je     40243d <_vsnprintf+0xc38>
  402424:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402427:	25 00 04 00 00       	and    $0x400,%eax
  40242c:	85 c0                	test   %eax,%eax
  40242e:	74 b6                	je     4023e6 <_vsnprintf+0xbe1>
  402430:	8b 45 f4             	mov    -0xc(%rbp),%eax
  402433:	8d 50 ff             	lea    -0x1(%rax),%edx
  402436:	89 55 f4             	mov    %edx,-0xc(%rbp)
  402439:	85 c0                	test   %eax,%eax
  40243b:	75 a9                	jne    4023e6 <_vsnprintf+0xbe1>
        }
        // post padding
        if (flags & FLAGS_LEFT) {
  40243d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402440:	83 e0 02             	and    $0x2,%eax
  402443:	85 c0                	test   %eax,%eax
  402445:	74 36                	je     40247d <_vsnprintf+0xc78>
          while (l++ < width) {
  402447:	eb 26                	jmp    40246f <_vsnprintf+0xc6a>
            out(' ', buffer, idx++, maxlen);
  402449:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40244d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  402451:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  402455:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  402459:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  40245d:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
  402461:	48 89 d1             	mov    %rdx,%rcx
  402464:	48 89 c2             	mov    %rax,%rdx
  402467:	bf 20 00 00 00       	mov    $0x20,%edi
  40246c:	41 ff d0             	call   *%r8
          while (l++ < width) {
  40246f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  402472:	8d 50 01             	lea    0x1(%rax),%edx
  402475:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  402478:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  40247b:	72 cc                	jb     402449 <_vsnprintf+0xc44>
          }
        }
        format++;
  40247d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  402481:	48 83 c0 01          	add    $0x1,%rax
  402485:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        break;
  402489:	e9 8b 01 00 00       	jmp    402619 <_vsnprintf+0xe14>
      }

      case 'p' : {
        width = sizeof(void*) * 2U;
  40248e:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
  402495:	83 4d fc 21          	orl    $0x21,-0x4(%rbp)
#if defined(PRINTF_SUPPORT_LONG_LONG)
        const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
  402499:	c6 45 cb 01          	movb   $0x1,-0x35(%rbp)
        if (is_ll) {
  40249d:	80 7d cb 00          	cmpb   $0x0,-0x35(%rbp)
  4024a1:	74 7f                	je     402522 <_vsnprintf+0xd1d>
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  4024a3:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4024a7:	8b 00                	mov    (%rax),%eax
  4024a9:	83 f8 2f             	cmp    $0x2f,%eax
  4024ac:	77 24                	ja     4024d2 <_vsnprintf+0xccd>
  4024ae:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4024b2:	48 8b 50 10          	mov    0x10(%rax),%rdx
  4024b6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4024ba:	8b 00                	mov    (%rax),%eax
  4024bc:	89 c0                	mov    %eax,%eax
  4024be:	48 01 d0             	add    %rdx,%rax
  4024c1:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  4024c5:	8b 12                	mov    (%rdx),%edx
  4024c7:	8d 4a 08             	lea    0x8(%rdx),%ecx
  4024ca:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  4024ce:	89 0a                	mov    %ecx,(%rdx)
  4024d0:	eb 14                	jmp    4024e6 <_vsnprintf+0xce1>
  4024d2:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4024d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  4024da:	48 8d 48 08          	lea    0x8(%rax),%rcx
  4024de:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  4024e2:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  4024e6:	48 8b 00             	mov    (%rax),%rax
  4024e9:	49 89 c0             	mov    %rax,%r8
  4024ec:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  4024f0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  4024f4:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  4024f8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  4024fc:	8b 7d fc             	mov    -0x4(%rbp),%edi
  4024ff:	57                   	push   %rdi
  402500:	8b 7d f8             	mov    -0x8(%rbp),%edi
  402503:	57                   	push   %rdi
  402504:	8b 7d f4             	mov    -0xc(%rbp),%edi
  402507:	57                   	push   %rdi
  402508:	6a 10                	push   $0x10
  40250a:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  402510:	48 89 c7             	mov    %rax,%rdi
  402513:	e8 e4 f1 ff ff       	call   4016fc <_ntoa_long_long>
  402518:	48 83 c4 20          	add    $0x20,%rsp
  40251c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  402520:	eb 7d                	jmp    40259f <_vsnprintf+0xd9a>
        }
        else {
#endif
          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
  402522:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402526:	8b 00                	mov    (%rax),%eax
  402528:	83 f8 2f             	cmp    $0x2f,%eax
  40252b:	77 24                	ja     402551 <_vsnprintf+0xd4c>
  40252d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402531:	48 8b 50 10          	mov    0x10(%rax),%rdx
  402535:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402539:	8b 00                	mov    (%rax),%eax
  40253b:	89 c0                	mov    %eax,%eax
  40253d:	48 01 d0             	add    %rdx,%rax
  402540:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  402544:	8b 12                	mov    (%rdx),%edx
  402546:	8d 4a 08             	lea    0x8(%rdx),%ecx
  402549:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  40254d:	89 0a                	mov    %ecx,(%rdx)
  40254f:	eb 14                	jmp    402565 <_vsnprintf+0xd60>
  402551:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  402555:	48 8b 40 08          	mov    0x8(%rax),%rax
  402559:	48 8d 48 08          	lea    0x8(%rax),%rcx
  40255d:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  402561:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  402565:	48 8b 00             	mov    (%rax),%rax
  402568:	49 89 c0             	mov    %rax,%r8
  40256b:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  40256f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402573:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  402577:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  40257b:	8b 7d fc             	mov    -0x4(%rbp),%edi
  40257e:	57                   	push   %rdi
  40257f:	8b 7d f8             	mov    -0x8(%rbp),%edi
  402582:	57                   	push   %rdi
  402583:	8b 7d f4             	mov    -0xc(%rbp),%edi
  402586:	57                   	push   %rdi
  402587:	6a 10                	push   $0x10
  402589:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  40258f:	48 89 c7             	mov    %rax,%rdi
  402592:	e8 5c f0 ff ff       	call   4015f3 <_ntoa_long>
  402597:	48 83 c4 20          	add    $0x20,%rsp
  40259b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#if defined(PRINTF_SUPPORT_LONG_LONG)
        }
#endif
        format++;
  40259f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  4025a3:	48 83 c0 01          	add    $0x1,%rax
  4025a7:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        break;
  4025ab:	eb 6c                	jmp    402619 <_vsnprintf+0xe14>
      }

      case '%' :
        out('%', buffer, idx++, maxlen);
  4025ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4025b1:	48 8d 50 01          	lea    0x1(%rax),%rdx
  4025b5:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  4025b9:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  4025bd:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  4025c1:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
  4025c5:	48 89 d1             	mov    %rdx,%rcx
  4025c8:	48 89 c2             	mov    %rax,%rdx
  4025cb:	bf 25 00 00 00       	mov    $0x25,%edi
  4025d0:	41 ff d0             	call   *%r8
        format++;
  4025d3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  4025d7:	48 83 c0 01          	add    $0x1,%rax
  4025db:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        break;
  4025df:	eb 38                	jmp    402619 <_vsnprintf+0xe14>

      default :
        out(*format, buffer, idx++, maxlen);
  4025e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4025e5:	48 8d 50 01          	lea    0x1(%rax),%rdx
  4025e9:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  4025ed:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  4025f1:	0f b6 12             	movzbl (%rdx),%edx
  4025f4:	0f be fa             	movsbl %dl,%edi
  4025f7:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  4025fb:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  4025ff:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
  402603:	48 89 d1             	mov    %rdx,%rcx
  402606:	48 89 c2             	mov    %rax,%rdx
  402609:	41 ff d0             	call   *%r8
        format++;
  40260c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  402610:	48 83 c0 01          	add    $0x1,%rax
  402614:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        break;
  402618:	90                   	nop
  while (*format)
  402619:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  40261d:	0f b6 00             	movzbl (%rax),%eax
  402620:	84 c0                	test   %al,%al
  402622:	0f 85 1c f2 ff ff    	jne    401844 <_vsnprintf+0x3f>
    }
  }

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
  402628:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40262c:	48 3b 45 98          	cmp    -0x68(%rbp),%rax
  402630:	72 0a                	jb     40263c <_vsnprintf+0xe37>
  402632:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  402636:	48 83 e8 01          	sub    $0x1,%rax
  40263a:	eb 04                	jmp    402640 <_vsnprintf+0xe3b>
  40263c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402640:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  402644:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  402648:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
  40264c:	48 89 d1             	mov    %rdx,%rcx
  40264f:	48 89 c2             	mov    %rax,%rdx
  402652:	bf 00 00 00 00       	mov    $0x0,%edi
  402657:	41 ff d0             	call   *%r8

  // return written chars without terminating \0
  return (int)idx;
  40265a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  40265e:	c9                   	leave
  40265f:	c3                   	ret

0000000000402660 <printf_>:


///////////////////////////////////////////////////////////////////////////////

int printf_(const char* format, ...)
{
  402660:	55                   	push   %rbp
  402661:	48 89 e5             	mov    %rsp,%rbp
  402664:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  40266b:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  402672:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  402679:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  402680:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  402687:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  40268e:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  402695:	84 c0                	test   %al,%al
  402697:	74 20                	je     4026b9 <printf_+0x59>
  402699:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  40269d:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  4026a1:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  4026a5:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  4026a9:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  4026ad:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  4026b1:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  4026b5:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  va_list va;
  va_start(va, format);
  4026b9:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  4026c0:	00 00 00 
  4026c3:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  4026ca:	00 00 00 
  4026cd:	48 8d 45 10          	lea    0x10(%rbp),%rax
  4026d1:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  4026d8:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  4026df:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  4026e6:	48 8d 8d 30 ff ff ff 	lea    -0xd0(%rbp),%rcx
  4026ed:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  4026f4:	48 8d 85 2f ff ff ff 	lea    -0xd1(%rbp),%rax
  4026fb:	49 89 c8             	mov    %rcx,%r8
  4026fe:	48 89 d1             	mov    %rdx,%rcx
  402701:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  402708:	48 89 c6             	mov    %rax,%rsi
  40270b:	48 8d 05 7d ea ff ff 	lea    -0x1583(%rip),%rax        # 40118f <_out_char>
  402712:	48 89 c7             	mov    %rax,%rdi
  402715:	e8 eb f0 ff ff       	call   401805 <_vsnprintf>
  40271a:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  va_end(va);
  return ret;
  402720:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  402726:	c9                   	leave
  402727:	c3                   	ret

0000000000402728 <sprintf_>:


int sprintf_(char* buffer, const char* format, ...)
{
  402728:	55                   	push   %rbp
  402729:	48 89 e5             	mov    %rsp,%rbp
  40272c:	48 81 ec e0 00 00 00 	sub    $0xe0,%rsp
  402733:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  40273a:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  402741:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  402748:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  40274f:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  402756:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  40275d:	84 c0                	test   %al,%al
  40275f:	74 20                	je     402781 <sprintf_+0x59>
  402761:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  402765:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  402769:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  40276d:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  402771:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  402775:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  402779:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  40277d:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  va_list va;
  va_start(va, format);
  402781:	c7 85 30 ff ff ff 10 	movl   $0x10,-0xd0(%rbp)
  402788:	00 00 00 
  40278b:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  402792:	00 00 00 
  402795:	48 8d 45 10          	lea    0x10(%rbp),%rax
  402799:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  4027a0:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  4027a7:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  4027ae:	48 8d 8d 30 ff ff ff 	lea    -0xd0(%rbp),%rcx
  4027b5:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  4027bc:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  4027c3:	49 89 c8             	mov    %rcx,%r8
  4027c6:	48 89 d1             	mov    %rdx,%rcx
  4027c9:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  4027d0:	48 89 c6             	mov    %rax,%rsi
  4027d3:	48 8d 05 6a e9 ff ff 	lea    -0x1696(%rip),%rax        # 401144 <_out_buffer>
  4027da:	48 89 c7             	mov    %rax,%rdi
  4027dd:	e8 23 f0 ff ff       	call   401805 <_vsnprintf>
  4027e2:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  va_end(va);
  return ret;
  4027e8:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  4027ee:	c9                   	leave
  4027ef:	c3                   	ret

00000000004027f0 <snprintf_>:


int snprintf_(char* buffer, size_t count, const char* format, ...)
{
  4027f0:	55                   	push   %rbp
  4027f1:	48 89 e5             	mov    %rsp,%rbp
  4027f4:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  4027fb:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  402802:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  402809:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
  402810:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  402817:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  40281e:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  402825:	84 c0                	test   %al,%al
  402827:	74 20                	je     402849 <snprintf_+0x59>
  402829:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  40282d:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  402831:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  402835:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  402839:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  40283d:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  402841:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  402845:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  va_list va;
  va_start(va, format);
  402849:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  402850:	00 00 00 
  402853:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  40285a:	00 00 00 
  40285d:	48 8d 45 10          	lea    0x10(%rbp),%rax
  402861:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  402868:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  40286f:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  402876:	48 8d b5 30 ff ff ff 	lea    -0xd0(%rbp),%rsi
  40287d:	48 8b 8d 18 ff ff ff 	mov    -0xe8(%rbp),%rcx
  402884:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  40288b:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  402892:	49 89 f0             	mov    %rsi,%r8
  402895:	48 89 c6             	mov    %rax,%rsi
  402898:	48 8d 05 a5 e8 ff ff 	lea    -0x175b(%rip),%rax        # 401144 <_out_buffer>
  40289f:	48 89 c7             	mov    %rax,%rdi
  4028a2:	e8 5e ef ff ff       	call   401805 <_vsnprintf>
  4028a7:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  va_end(va);
  return ret;
  4028ad:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  4028b3:	c9                   	leave
  4028b4:	c3                   	ret

00000000004028b5 <vprintf_>:


int vprintf_(const char* format, va_list va)
{
  4028b5:	55                   	push   %rbp
  4028b6:	48 89 e5             	mov    %rsp,%rbp
  4028b9:	48 83 ec 20          	sub    $0x20,%rsp
  4028bd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4028c1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  char buffer[1];
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  4028c5:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  4028c9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  4028cd:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  4028d1:	49 89 c8             	mov    %rcx,%r8
  4028d4:	48 89 d1             	mov    %rdx,%rcx
  4028d7:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  4028de:	48 89 c6             	mov    %rax,%rsi
  4028e1:	48 8d 05 a7 e8 ff ff 	lea    -0x1759(%rip),%rax        # 40118f <_out_char>
  4028e8:	48 89 c7             	mov    %rax,%rdi
  4028eb:	e8 15 ef ff ff       	call   401805 <_vsnprintf>
}
  4028f0:	c9                   	leave
  4028f1:	c3                   	ret

00000000004028f2 <vsnprintf_>:


int vsnprintf_(char* buffer, size_t count, const char* format, va_list va)
{
  4028f2:	55                   	push   %rbp
  4028f3:	48 89 e5             	mov    %rsp,%rbp
  4028f6:	48 83 ec 20          	sub    $0x20,%rsp
  4028fa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  4028fe:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  402902:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  402906:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  return _vsnprintf(_out_buffer, buffer, count, format, va);
  40290a:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  40290e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  402912:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  402916:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40291a:	49 89 f0             	mov    %rsi,%r8
  40291d:	48 89 c6             	mov    %rax,%rsi
  402920:	48 8d 05 1d e8 ff ff 	lea    -0x17e3(%rip),%rax        # 401144 <_out_buffer>
  402927:	48 89 c7             	mov    %rax,%rdi
  40292a:	e8 d6 ee ff ff       	call   401805 <_vsnprintf>
}
  40292f:	c9                   	leave
  402930:	c3                   	ret

0000000000402931 <fctprintf>:


int fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)
{
  402931:	55                   	push   %rbp
  402932:	48 89 e5             	mov    %rsp,%rbp
  402935:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  40293c:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  402943:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  40294a:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  402951:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  402958:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  40295f:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  402966:	84 c0                	test   %al,%al
  402968:	74 20                	je     40298a <fctprintf+0x59>
  40296a:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  40296e:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  402972:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  402976:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  40297a:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  40297e:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  402982:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  402986:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  va_list va;
  va_start(va, format);
  40298a:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  402991:	00 00 00 
  402994:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  40299b:	00 00 00 
  40299e:	48 8d 45 10          	lea    0x10(%rbp),%rax
  4029a2:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  4029a9:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  4029b0:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  const out_fct_wrap_type out_fct_wrap = { out, arg };
  4029b7:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  4029be:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  4029c5:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  4029cc:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  4029d3:	48 8d 8d 30 ff ff ff 	lea    -0xd0(%rbp),%rcx
  4029da:	48 8b 95 08 ff ff ff 	mov    -0xf8(%rbp),%rdx
  4029e1:	48 8d 85 20 ff ff ff 	lea    -0xe0(%rbp),%rax
  4029e8:	49 89 c8             	mov    %rcx,%r8
  4029eb:	48 89 d1             	mov    %rdx,%rcx
  4029ee:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  4029f5:	48 89 c6             	mov    %rax,%rsi
  4029f8:	48 8d 05 bd e7 ff ff 	lea    -0x1843(%rip),%rax        # 4011bc <_out_fct>
  4029ff:	48 89 c7             	mov    %rax,%rdi
  402a02:	e8 fe ed ff ff       	call   401805 <_vsnprintf>
  402a07:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  va_end(va);
  return ret;
  402a0d:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  402a13:	c9                   	leave
  402a14:	c3                   	ret

0000000000402a15 <_putchar>:
static void _putchar(char character) {
  402a15:	55                   	push   %rbp
  402a16:	48 89 e5             	mov    %rsp,%rbp
  402a19:	48 83 ec 10          	sub    $0x10,%rsp
  402a1d:	89 f8                	mov    %edi,%eax
  402a1f:	88 45 fc             	mov    %al,-0x4(%rbp)
    write(1, &character, 1);
  402a22:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  402a26:	ba 01 00 00 00       	mov    $0x1,%edx
  402a2b:	48 89 c6             	mov    %rax,%rsi
  402a2e:	bf 01 00 00 00       	mov    $0x1,%edi
  402a33:	e8 2f 00 00 00       	call   402a67 <write>
}
  402a38:	90                   	nop
  402a39:	c9                   	leave
  402a3a:	c3                   	ret

0000000000402a3b <open>:
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <syscall.h>

int open(const char *pathname, int flags, mode_t mode) {
  402a3b:	55                   	push   %rbp
  402a3c:	48 89 e5             	mov    %rsp,%rbp
  402a3f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402a43:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  402a46:	89 55 e0             	mov    %edx,-0x20(%rbp)
    return __syscall3(2, (size_t) pathname, flags, mode);
  402a49:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  402a4d:	b8 02 00 00 00       	mov    $0x2,%eax
  402a52:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  402a55:	8b 55 e0             	mov    -0x20(%rbp),%edx
  402a58:	48 89 cf             	mov    %rcx,%rdi
  402a5b:	cd 80                	int    $0x80
  402a5d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  402a61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402a65:	5d                   	pop    %rbp
  402a66:	c3                   	ret

0000000000402a67 <write>:

size_t write(int fd, const void *buf, size_t count) {
  402a67:	55                   	push   %rbp
  402a68:	48 89 e5             	mov    %rsp,%rbp
  402a6b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  402a6e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  402a72:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    return __syscall3(1, (size_t) fd, buf, count);
  402a76:	8b 45 ec             	mov    -0x14(%rbp),%eax
  402a79:	48 63 c8             	movslq %eax,%rcx
  402a7c:	b8 01 00 00 00       	mov    $0x1,%eax
  402a81:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  402a85:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  402a89:	48 89 cf             	mov    %rcx,%rdi
  402a8c:	cd 80                	int    $0x80
  402a8e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  402a92:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402a96:	5d                   	pop    %rbp
  402a97:	c3                   	ret

0000000000402a98 <__syscall1>:
	__asm__ __volatile__ ("int $0x80" : "=a"(ret) : "a"(n) : "rcx", "r11", "memory");
	return ret;
}

static __inline long __syscall1(long n, long a1)
{
  402a98:	55                   	push   %rbp
  402a99:	48 89 e5             	mov    %rsp,%rbp
  402a9c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402aa0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	unsigned long long ret;
	__asm__ __volatile__ ("int $0x80" : "=a"(ret) : "a"(n), "D"(a1) : "memory");
  402aa4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402aa8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  402aac:	48 89 d7             	mov    %rdx,%rdi
  402aaf:	cd 80                	int    $0x80
  402ab1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return ret;
  402ab5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402ab9:	5d                   	pop    %rbp
  402aba:	c3                   	ret

0000000000402abb <exit>:
#include <stdlib.h>
#include <unistd.h>
#include <syscall.h>

__attribute__((noreturn))
void exit(int status) {
  402abb:	55                   	push   %rbp
  402abc:	48 89 e5             	mov    %rsp,%rbp
  402abf:	48 83 ec 08          	sub    $0x8,%rsp
  402ac3:	89 7d fc             	mov    %edi,-0x4(%rbp)
    __syscall1(4, status);
  402ac6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402ac9:	48 98                	cltq
  402acb:	48 89 c6             	mov    %rax,%rsi
  402ace:	bf 04 00 00 00       	mov    $0x4,%edi
  402ad3:	e8 c0 ff ff ff       	call   402a98 <__syscall1>
    for (;;);
  402ad8:	eb fe                	jmp    402ad8 <exit+0x1d>

0000000000402ada <create_pool>:
#define PAGE_ALIGN_DOWN(addr) ((addr / 4096) * 4096)
#define PAGE_ALIGN_UP(x) ((((x) + 4095) / 4096) * 4096)

extern HeapPool start_heap;

HeapPool create_pool(uint64_t size, uint64_t required_size, HeapPool *next, bool free) {
  402ada:	55                   	push   %rbp
  402adb:	48 89 e5             	mov    %rsp,%rbp
  402ade:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  402ae2:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  402ae6:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  402aea:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  402aee:	44 89 c0             	mov    %r8d,%eax
  402af1:	88 45 bc             	mov    %al,-0x44(%rbp)
    HeapPool pool;
    pool.verify        = 69;
  402af4:	c6 45 e0 45          	movb   $0x45,-0x20(%rbp)
    pool.size          = size - 1;
  402af8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  402afc:	48 83 e8 01          	sub    $0x1,%rax
  402b00:	48 89 45 e9          	mov    %rax,-0x17(%rbp)
    pool.required_size = required_size;
  402b04:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  402b08:	48 89 45 f1          	mov    %rax,-0xf(%rbp)
    pool.next          = next;
  402b0c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  402b10:	48 89 45 e1          	mov    %rax,-0x1f(%rbp)
    pool.free          = free;
  402b14:	0f b6 45 bc          	movzbl -0x44(%rbp),%eax
  402b18:	88 45 f9             	mov    %al,-0x7(%rbp)
    return pool;
  402b1b:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  402b1f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402b23:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402b27:	48 89 01             	mov    %rax,(%rcx)
  402b2a:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  402b2e:	48 8b 45 ea          	mov    -0x16(%rbp),%rax
  402b32:	48 8b 55 f2          	mov    -0xe(%rbp),%rdx
  402b36:	48 89 41 0a          	mov    %rax,0xa(%rcx)
  402b3a:	48 89 51 12          	mov    %rdx,0x12(%rcx)
}
  402b3e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402b42:	5d                   	pop    %rbp
  402b43:	c3                   	ret

0000000000402b44 <split_pool>:

void* split_pool(HeapPool *pool_addr, uint64_t size) {
  402b44:	55                   	push   %rbp
  402b45:	48 89 e5             	mov    %rsp,%rbp
  402b48:	53                   	push   %rbx
  402b49:	48 83 ec 48          	sub    $0x48,%rsp
  402b4d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  402b51:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    HeapPool *new_pool = (HeapPool*) (((uint64_t) pool_addr) + pool_addr->required_size + 1);
  402b55:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402b59:	48 8b 50 11          	mov    0x11(%rax),%rdx
  402b5d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402b61:	48 01 d0             	add    %rdx,%rax
  402b64:	48 83 c0 01          	add    $0x1,%rax
  402b68:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    uint64_t new_pool_size = sizeof(HeapPool) + size;
  402b6c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  402b70:	48 83 c0 1a          	add    $0x1a,%rax
  402b74:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    *new_pool = create_pool(pool_addr->size - pool_addr->required_size, new_pool_size, pool_addr->next, false);
  402b78:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402b7c:	48 8b 48 01          	mov    0x1(%rax),%rcx
  402b80:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402b84:	48 8b 50 09          	mov    0x9(%rax),%rdx
  402b88:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402b8c:	48 8b 40 11          	mov    0x11(%rax),%rax
  402b90:	48 89 d6             	mov    %rdx,%rsi
  402b93:	48 29 c6             	sub    %rax,%rsi
  402b96:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  402b9a:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  402b9e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  402ba2:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  402ba8:	48 89 c7             	mov    %rax,%rdi
  402bab:	e8 2a ff ff ff       	call   402ada <create_pool>
  402bb0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  402bb4:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  402bb8:	48 89 03             	mov    %rax,(%rbx)
  402bbb:	48 89 53 08          	mov    %rdx,0x8(%rbx)
  402bbf:	48 8b 45 ba          	mov    -0x46(%rbp),%rax
  402bc3:	48 8b 55 c2          	mov    -0x3e(%rbp),%rdx
  402bc7:	48 89 43 0a          	mov    %rax,0xa(%rbx)
  402bcb:	48 89 53 12          	mov    %rdx,0x12(%rbx)
    pool_addr->size = pool_addr->required_size;
  402bcf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402bd3:	48 8b 50 11          	mov    0x11(%rax),%rdx
  402bd7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402bdb:	48 89 50 09          	mov    %rdx,0x9(%rax)
    pool_addr->next = new_pool;
  402bdf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402be3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402be7:	48 89 50 01          	mov    %rdx,0x1(%rax)
    return (void*)new_pool;
  402beb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  402bef:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  402bf3:	c9                   	leave
  402bf4:	c3                   	ret

0000000000402bf5 <heap_grow>:

void* heap_grow(size_t size, HeapPool *this_pool) {
  402bf5:	55                   	push   %rbp
  402bf6:	48 89 e5             	mov    %rsp,%rbp
  402bf9:	53                   	push   %rbx
  402bfa:	48 83 ec 48          	sub    $0x48,%rsp
  402bfe:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  402c02:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    uint64_t new_pool_size = PAGE_ALIGN_UP(size + sizeof(HeapPool));
  402c06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402c0a:	48 05 19 10 00 00    	add    $0x1019,%rax
  402c10:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  402c16:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    this_pool->next = sbrk(new_pool_size);
  402c1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402c1e:	48 89 c7             	mov    %rax,%rdi
  402c21:	e8 c4 01 00 00       	call   402dea <sbrk>
  402c26:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  402c2a:	48 89 42 01          	mov    %rax,0x1(%rdx)
    *((HeapPool*) this_pool->next) = create_pool(new_pool_size, size + sizeof(HeapPool), 0, false);
  402c2e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402c32:	48 8d 50 1a          	lea    0x1a(%rax),%rdx
  402c36:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  402c3a:	48 8b 58 01          	mov    0x1(%rax),%rbx
  402c3e:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  402c42:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  402c46:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  402c4c:	b9 00 00 00 00       	mov    $0x0,%ecx
  402c51:	48 89 c7             	mov    %rax,%rdi
  402c54:	e8 81 fe ff ff       	call   402ada <create_pool>
  402c59:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  402c5d:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  402c61:	48 89 03             	mov    %rax,(%rbx)
  402c64:	48 89 53 08          	mov    %rdx,0x8(%rbx)
  402c68:	48 8b 45 ba          	mov    -0x46(%rbp),%rax
  402c6c:	48 8b 55 c2          	mov    -0x3e(%rbp),%rdx
  402c70:	48 89 43 0a          	mov    %rax,0xa(%rbx)
  402c74:	48 89 53 12          	mov    %rdx,0x12(%rbx)
    return (void*) ((HeapPool*) this_pool->next)->data;
  402c78:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  402c7c:	48 8b 40 01          	mov    0x1(%rax),%rax
  402c80:	48 83 c0 1a          	add    $0x1a,%rax
}
  402c84:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  402c88:	c9                   	leave
  402c89:	c3                   	ret

0000000000402c8a <malloc>:

void* malloc(uint64_t size) {
  402c8a:	55                   	push   %rbp
  402c8b:	48 89 e5             	mov    %rsp,%rbp
  402c8e:	48 83 ec 20          	sub    $0x20,%rsp
  402c92:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    HeapPool *this_pool = &start_heap;
  402c96:	48 8d 05 63 13 00 00 	lea    0x1363(%rip),%rax        # 404000 <start_heap>
  402c9d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    for (;;) {
        if (this_pool->free && this_pool->size > size + sizeof(HeapPool)) {
  402ca1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402ca5:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  402ca9:	84 c0                	test   %al,%al
  402cab:	74 37                	je     402ce4 <malloc+0x5a>
  402cad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402cb1:	48 8b 40 09          	mov    0x9(%rax),%rax
  402cb5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402cb9:	48 83 c2 1a          	add    $0x1a,%rdx
  402cbd:	48 39 c2             	cmp    %rax,%rdx
  402cc0:	73 22                	jae    402ce4 <malloc+0x5a>
            this_pool->free = false;
  402cc2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402cc6:	c6 40 19 00          	movb   $0x0,0x19(%rax)
            this_pool->required_size = size + sizeof(HeapPool);
  402cca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402cce:	48 8d 50 1a          	lea    0x1a(%rax),%rdx
  402cd2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402cd6:	48 89 50 11          	mov    %rdx,0x11(%rax)
            return (void*) this_pool->data;
  402cda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402cde:	48 83 c0 1a          	add    $0x1a,%rax
  402ce2:	eb 74                	jmp    402d58 <malloc+0xce>
        } else if (this_pool->size > this_pool->required_size + size + sizeof(HeapPool)) {
  402ce4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402ce8:	48 8b 40 09          	mov    0x9(%rax),%rax
  402cec:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  402cf0:	48 8b 4a 11          	mov    0x11(%rdx),%rcx
  402cf4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402cf8:	48 01 ca             	add    %rcx,%rdx
  402cfb:	48 83 c2 1a          	add    $0x1a,%rdx
  402cff:	48 39 c2             	cmp    %rax,%rdx
  402d02:	73 21                	jae    402d25 <malloc+0x9b>
            HeapPool *new_pool = (HeapPool*) split_pool(this_pool, size);
  402d04:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402d08:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402d0c:	48 89 d6             	mov    %rdx,%rsi
  402d0f:	48 89 c7             	mov    %rax,%rdi
  402d12:	e8 2d fe ff ff       	call   402b44 <split_pool>
  402d17:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
            return (void*) new_pool->data;
  402d1b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402d1f:	48 83 c0 1a          	add    $0x1a,%rax
  402d23:	eb 33                	jmp    402d58 <malloc+0xce>
        } else if (this_pool->next == 0) {
  402d25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402d29:	48 8b 40 01          	mov    0x1(%rax),%rax
  402d2d:	48 85 c0             	test   %rax,%rax
  402d30:	75 15                	jne    402d47 <malloc+0xbd>
            return heap_grow(size, this_pool);
  402d32:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  402d36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402d3a:	48 89 d6             	mov    %rdx,%rsi
  402d3d:	48 89 c7             	mov    %rax,%rdi
  402d40:	e8 b0 fe ff ff       	call   402bf5 <heap_grow>
  402d45:	eb 11                	jmp    402d58 <malloc+0xce>
        }
        this_pool = (HeapPool*) this_pool->next;
  402d47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402d4b:	48 8b 40 01          	mov    0x1(%rax),%rax
  402d4f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        if (this_pool->free && this_pool->size > size + sizeof(HeapPool)) {
  402d53:	e9 49 ff ff ff       	jmp    402ca1 <malloc+0x17>
    }
}
  402d58:	c9                   	leave
  402d59:	c3                   	ret

0000000000402d5a <free>:

void free(void* addr) {
  402d5a:	55                   	push   %rbp
  402d5b:	48 89 e5             	mov    %rsp,%rbp
  402d5e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    HeapPool *this_pool      = (HeapPool*) (((uint64_t)addr) - sizeof(HeapPool));
  402d62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402d66:	48 83 e8 1a          	sub    $0x1a,%rax
  402d6a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (this_pool->verify != 69) return;
  402d6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402d72:	0f b6 00             	movzbl (%rax),%eax
  402d75:	3c 45                	cmp    $0x45,%al
  402d77:	75 16                	jne    402d8f <free+0x35>
    this_pool->free          = true;
  402d79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402d7d:	c6 40 19 01          	movb   $0x1,0x19(%rax)
    this_pool->required_size = sizeof(HeapPool);
  402d81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402d85:	48 c7 40 11 1a 00 00 	movq   $0x1a,0x11(%rax)
  402d8c:	00 
  402d8d:	eb 01                	jmp    402d90 <free+0x36>
    if (this_pool->verify != 69) return;
  402d8f:	90                   	nop
}
  402d90:	5d                   	pop    %rbp
  402d91:	c3                   	ret

0000000000402d92 <strlen>:
#include <string.h>

size_t strlen(const char *str) {
  402d92:	55                   	push   %rbp
  402d93:	48 89 e5             	mov    %rsp,%rbp
  402d96:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    size_t len = 0;
  402d9a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  402da1:	00 
    while (str[len]) len++;
  402da2:	eb 05                	jmp    402da9 <strlen+0x17>
  402da4:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  402da9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  402dad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402db1:	48 01 d0             	add    %rdx,%rax
  402db4:	0f b6 00             	movzbl (%rax),%eax
  402db7:	84 c0                	test   %al,%al
  402db9:	75 e9                	jne    402da4 <strlen+0x12>
    return len;
  402dbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402dbf:	5d                   	pop    %rbp
  402dc0:	c3                   	ret

0000000000402dc1 <__syscall1>:
{
  402dc1:	55                   	push   %rbp
  402dc2:	48 89 e5             	mov    %rsp,%rbp
  402dc5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402dc9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	__asm__ __volatile__ ("int $0x80" : "=a"(ret) : "a"(n), "D"(a1) : "memory");
  402dcd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402dd1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  402dd5:	48 89 d7             	mov    %rdx,%rdi
  402dd8:	cd 80                	int    $0x80
  402dda:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return ret;
  402dde:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402de2:	5d                   	pop    %rbp
  402de3:	c3                   	ret

0000000000402de4 <__stack_chk_fail>:
#else
    #define STACK_CHK_GUARD 0x595e9fbd94fda766
#endif
uintptr_t __stack_chk_guard = STACK_CHK_GUARD;
__attribute__((noreturn))
void __stack_chk_fail(void) {
  402de4:	55                   	push   %rbp
  402de5:	48 89 e5             	mov    %rsp,%rbp
    for (;;); // TODO: Handle properly
  402de8:	eb fe                	jmp    402de8 <__stack_chk_fail+0x4>

0000000000402dea <sbrk>:
}

void *sbrk(intptr_t increment) {
  402dea:	55                   	push   %rbp
  402deb:	48 89 e5             	mov    %rsp,%rbp
  402dee:	48 83 ec 08          	sub    $0x8,%rsp
  402df2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return (void*) __syscall1(11, increment);
  402df6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402dfa:	48 89 c6             	mov    %rax,%rsi
  402dfd:	bf 0b 00 00 00       	mov    $0xb,%edi
  402e02:	e8 ba ff ff ff       	call   402dc1 <__syscall1>
}
  402e07:	c9                   	leave
  402e08:	c3                   	ret
